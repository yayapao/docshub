---
id: network
title: Network
sidebar_label: Network
---

[中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程](https://www.bilibili.com/video/BV1JV411t7ow?p=4)
[国防科技大学 - 计算机网络](https://www.bilibili.com/video/BV1ft411G7Bu?p=2&spm_id_from=pageDriver)

## 传输层

理解传输层原理
- 多路复用/解复用
- **RDT 可靠数据传输**
- 流量控制
- 拥塞控制

两种协议
- UDP 无连接服务，不可靠、不保序
- TCP 面向连接服务，保证数据可靠、保序

传输层提供的服务是 进程到进程，将应用层的传递数据切分成 报文段，并添加 请求头，到达对端后，解析报文段以 流 的形式传递给应用层

复用/解复用，源端的应用进程都用一个传输层实体（比如 TCP 实例）进行发送，在对端，都通过一个 传输层实体进行进程分配，即解复用


## 网络基础

### 网络结构

互联网的结构可以分为：
- 网络边缘（edge），比如主机、服务器
- 网络核心（core），比如交换机
- 接入网和物理媒介（access），用来连接边缘和核心



## 进程通信

在操作系统中，进行通信的实际上是进程（process）而不是程序。一个进程可以被认为是运行在端系统的一个程序

当进程运行在相同的端系统(即同一电脑)上时，它们使用进程间的通信机制相互通信。进程间通信的规则由端系统上的操作系统确定

在两个不同端系统上的进程，通过跨越计算机网络交换报文而相互通信。发送进程生成报文并发送到网络中，接收进程接收这些报文并可能通过将报文发送回去进行响应

定义客户和服务器进程：在给定的一对进程之间的通信会话场景中，**发起通信** （即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时 **等待联系** 的进程是服务器

进程间通过套接字（socket）软件接口向网络发送或者接收报文

套接字是同一台主机内应用层和传输层之间的 **接口**，由于套接字是建立网络应用程序的可编程接口，因此套接字也被称为应用程序和网络之间的应用程序编程接口（API）

通过 ip（主机地址） 和 port（主机中接收进程标识符）来标识进程通信中的接收进程


## DNS 因特网的目录服务

主机名和IP地址是识别主机的两种方式，人们喜欢主机名的标记方式，而路由器则更喜欢定长的，有着层次结构的IP地址，为此，我们需要一种能进行主机名到IP地址转换的目录服务，这就是域名系统（Domain Name System, DNS）

- DNS是一个由分层的DNS服务器实现的分布式数据库
- 一个使得主机能够查询分布式数据库的应用层协议
- DNS 协议运行在 UDP 之上，使用53端口

当用户在浏览器上请求一个 URL 地址：

- 同一台主机上运行着DNS客户端
- 浏览器从 URL 中抽取出主机名，并将其传递给DNS客户端
- DNS客户端向DNS服务器发送一个包含主机名的请求
- DNS客户端收到一份响应豹纹。里面包含该主机名的IP地址
- 一旦浏览器接受来自DNS的该IP地址，它就能够向指定服务器发起一个TCP连接

DNS 服务器请求过程：请求主机 - 本地 DNS 服务器 - 根 DNS 服务器 - 顶级域 DNS 服务器

DNS 缓存是DNS系统一个非常重要的特色，它能够改善延时性能并减少在网络上的DNS的报文数量，但是其缓存不是永久存在的，通常存储2天

通过本地主机向DNS服务器发送 DNS查询报文: 通过 `nslookup` 调用 nslookup 程序，然后输入 Web 站点即可

利用 DNS 进行攻击的几种方式：
- DDoS 通过向每个 DNS 服务器发送大量分组，使得大多数合法的 DNS 请求得不到回答
- 中间人攻击，攻击者截获来自主机的请求并返回伪造的回答
- DNS毒害攻击，攻击者向一台 DNS 服务器发送伪造的回答，诱使服务器在它的缓存中接收伪造的记录


## HTTP

:::tip
HTTP 使用 TCP 作为它的支撑运输协议
:::

Web 应用的底层协议是超文本传输协议（HyperText Transfer Protocol, HTTP），这是 Web 的核心，它定义了web客户与web服务器之间进行 http报文 交换的方式以及这些报文的结构（即如何交互和交互数据结构）

Web 页面由**对象**组成，一个对象就是一个文件，该文件可以是一个 .html文件，一个 .jpg图片等等，比如：一个 Web 页面包含1个 html 基本文件和2个 css 引用文件，则这个 Web 页面包含3个对象

![HTTP请求/响应](/img/notes/tcp.png)

- HTTP客户首先通过发起一个与服务器的**TCP连接请求**，一旦连接建立，该浏览器与服务器进程就可以通过套接字接口访问 TCP，然后客户和服务器从它的套接字发送或者接收 HTTP 报文

- 一旦客户向它的套接字发送了一个**HTTP请求报文**，该报文就脱离了客户控制并进入 TCP 控制，由于 TCP 为 HTTP 提供可靠数据传输服务，所以在客户和服务器交换报文的过程，不必担心数据丢失

- 这也体现了分层体系的 **最大优点** ：HTTP 协议不必担心数据丢失，也不必了解 TCP 从网络的数据丢失和乱序故障中恢复的细节

- HTTP 服务器 **不会** 保存关于客户的任何信息，所以 HTTP 是无状态协议，这意味着服务器不会因为刚刚为该用户提供了对象就不再响应，而是会重新发送该对象


### HTTP状态码

记录项目使用过程中常用的状态码：

200 请求成功

302：重定向状态码表明请求的资源被暂时的移动到了由Location 头部指定的URL上，在通过后端转发接口是可以触发

304 not modified 资源没有发生改变，有响应报文但是不返回具体资源

- 可以关联到 http 缓存的协商缓存，`E-tag/If-None-Match`, `Last-Modified/If-Modified-Since`


400 - bad request 通用的客户端错误状态码，其他 4xx 不适用时返回

403 - forbidden 理解了请求，但是拒绝执行，一般是验证不通过

404 not found 找不到指定资源

- 接口路径正确，但是找不到指定的资源，比如图片呢
- 服务器就没有提供指定的接口
- koa2 下如果因为代码问题，比如没有编写 `ctx.body = result` 也会返回 404

405 - Method Not Allowed 指定资源不支持该方法，比如指定post，发送一个 get 请求

431 - Request Header Fields Too Large get方法请求头内params太多引起

500 Internet Server Eroor 服务器错误

- 如果服务器还没启动，则会返回该错误

502 bad geteway

- CPU, 内存占用过高
- koa2 如果没有执行 `npm install` 导致运行时有包缺失的时候，也会报502错误


### RTT

RTT指往返时间（Round-Trip Time），该时间指一个短分组从客户到服务器然后再返回客户所花费的时间

RTT = 分组时延 + 分组在中间路由器和交换机上的排队时延 + 分组处理时延

大致上说，一次 HTTP 请求/响应时间等于两次 RTT 加上服务器文件传输文件的时间

### HTTP请求报文

```
// 请求行，包含三个字段：请求方法，URL，HTTP版本
POST http://172.17.2.42/api/task/list-task-for-applicant http/1.1

// 首部行
// Host 指明了对象所在的主机，该字段提供的信息是 Web 代理高速缓存所要求的
Host: 172.17.2.42

// Connection 告诉服务器是否需要持续使用该连接，可取值 keep-alive 或者 close
Connection: keep-alive

// User-Agent 用来指明用户代理，即向服务器发送请求的浏览器类型
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3390.0 Safari/537.36

// Accept-Language 表示用户想要得到该对象的语言版本
Accept-Language: zh-CN,zh;q=0.9
```

HTTP 请求报文的通用格式：请求行，首部行，空行，实体主体

HTTP 请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）

使用 GET 方法时，实体主体为空，使用 POST 方法时，才使用实体主体

### HTTP响应报文

```
// 状态行包含三个字段：协议版本，状态码和相应的状态信息
HTTP/1.1 200 OK

// 首部行
// Server 指示该报文是由 nginx/1.10.1 服务器产生的
Server: nginx/1.10.1

// Date 指示服务器从它的文件系统找到该对象，插入到响应报文，并且发送该响应报文的日期和时间
Date: Sun, 08 Apr 2018 08:47:04 GMT

// Content-Type 指示了实体主体中的对象类型
Content-Type: application/json;charset=UTF-8

// Connection 告诉客户是否需要持续使用该连接，可取值 keep-alive 或者 close
Connection: keep-alive

// Last-Modified 最后修改日期和时间，对于本地客户和代理服务器上的对象缓存来说很重要
Last-Modified: Sun, 08 Apr 2018 08:46:04 GMT

entity body data...
```

HTTP 响应报文的通用格式：状态行，首部行，空行，实体主体

实体主体是响应报文的主要部分，它包含了所请求的对象本身


## TCP连接方式

客户到服务器的每个请求/响应是经单独的 TCP 连接发送，则该应用程序使用非持续连接（non-persistent connection）,每个 TCP 连接在服务器发送一个对象后关闭，即每个 TCP 连接只传输一个请求报文和一个响应报文

由此可见，非持续连接的缺点在于：

- 必须为每一个请求对象建立和维护一个全新的连接，对于每个这样的连接，在客户和服务器都要分配 TCP 的缓冲区和保持 TCP 变量
- 每个对象都要经受两倍 RTT 的交付时延

客户到服务器的所有请求/响应是经相同的 TCP 连接发送，则该应用程序使用持续连接（presistent connection）。即服务器在发送响应后保持该 TCP 连接打开，在相同的客户与服务器之间的后续请求和响应报文能够通过相同的连接进行传输

HTTP 在其默认方式下使用持续连接，通过 `Connection: keep-alive` 标识

## 三次握手

假设客户上的一个进程想与服务器上的某一个进程建立一条连接。客户应用进程首先通知客户TCP，它希望建立一个与服务器上某个进程之间的连接。客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接

![three-hands](/img/notes/three-hands.jpg)

客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段（SYN报文段），该报文段会被封装在一个IP数据报中，并发送给服务器

- 该报文段不包含应用层数据
- 报文段的首部中一个标志位（SYN比特）被置为1
- 客户会随机选择一个初始序号置于序号字段中

一旦包含 TCP SYN报文段的IP数据报到达服务器，服务器就会从数据报中提取出 TCP SYN报文段，为该 TCP连接分配TCP缓存和变量，并向客户TCP 发送允许连接的报文段（SYNACK 报文段）

- 这个允许连接的报文段不包含应用层数据
- 报文段首部的 SYN比特 置为1
- 报文段首部的确认号被置为 （SYN报文段序号 + 1）
- 服务器选择自己的初始序号，并将其置于 TCP报文段 首部的序号字段

客户接收到 SYNACK报文段之后，为该连接分配缓存和变量，并向服务器发送一个报文段

- 该报文段对服务器的 SYNACK报文段 进行确认，通过设置确认号为 SYNACK报文段首部的序号字段 + 1 实现
- 报文段首部的 SYN比特 置为0
- 可以在报文段负载中携带客户到服务器的数据

一旦完成以上三个步骤，客户和服务器就可以相互发送包括数据的报文段了，并且在以后每个报文段，SYN比特都被置为0

## 四次分手

四次分手用于关闭 TCP 连接

参与一条 TCP 连接的两个进程中的任何一个都能终止该连接，当链接结束之后，客户和服务器的资源（即缓存和变量）将被释放

![four-hands](/img/notes/four-hands.png)

假如某客户打算关闭连接，客户应用进程发出一个关闭连接的命令：

1. 客户TCP 向 服务器发送一个特殊的 TCP报文段，这个报文段让其首部的 FIN比特 被置为1

2. 当服务器接收到该报文段后，就向客户发送一个确认报文段

3. 服务器主动发送它自己的终止报文段，其 FIN比特 被置为1

4. 最终，客户对服务器的终止报文段进行确认，此时，两台主机上用于该连接的所有资源都被释放


## Cookie  

cookie 可以在无状态的 HTTP 之上建立一个用户会话层，允许站点对用户进行跟踪

cookie 技术包含四个组件：

- 在 HTTP 响应报文中有一个 cookie 首部行
- 在 HTTP 请求报文中有一个 cookie 首部行
- 在用户端系统中保留一个 cookie 文件，并由用户的浏览器进行管理
- 位于 Web 站点的一个后端数据库

![Cookie](/img/notes/cookie.png)

Web 缓存器也叫代理服务器，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体

在 Internet 上部署代理服务器的两个原因：

- 代理服务器可以大大减少对客户请求的响应时间

- 代理服务器可以大大减少一个机构的接入链路到 Internet 的通信量   

HTTP 协议有一种机制，允许代理服务器证实它的对象是最新的，这种机制就是条件GET方法

条件GET方法实现要求：

- 请求报文使用 GET 方法
- 请求报文中含有 If-Modified-Since 首部行

代理服务器在存储响应对象的同时，也对其响应报文的 `Last-Modified` 值进行存储，当同一对象再次被请求时，代理服务器会在请求报文中添加 `If-Modified-Since` 字段，且其值等于之前存储的 `Last-Modified` 的值，通过该条件GET方法告诉服务器，仅当自指定日期之后该对象被修改过，才发送此对象

如果响应对象未被修改，则 Web 服务器还是会向代理服务器发送响应报文，但是该响应报文中不包含所请求的对象，并且最后响应报文中，状态行为 304 Not Modified
