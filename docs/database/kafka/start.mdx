---
id: start
title: ''
sidebar_label: QuickStart
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="Kafka QuickStart"
  description="Kafka is a distributed messaging system providing fast, highly scalable and redundant messaging through a pub-sub model."
  github="https://github.com/apache/kafka"
  tags={['distributed', 'streaming', 'message', 'pub/sub mode']}
  links={[
    {
      label: 'Kafka in a Nutshell',
      link: 'https://sookocheff.com/post/kafka/kafka-in-a-nutshell/',
    },
    {
      label: 'Kafka入门介绍',
      link: 'https://lotabout.me/2018/kafka-introduction/',
    },
  ]}
/>{' '}

## Kafka in a Nutshell

在本章节我将介绍 Kafka 的术语以及基础知识。

让我们先从[kafka-go](https://github.com/segmentio/kafka-go#connection-)的示例中一探究竟。

```go
conn, err := kafka.DialLeader(context.Background(), "tcp", "localhost:9092", topic, partition)
```

不难看出，新建一个基本的 kafka client 实例需要**协议、地址、topic name 以及 partition 数量**，并确定当前的 Leader。**Leader 用于收发数据，并且作为其他 broker 冗余（replication）的母本。**

因此我们有必要掌握 Kafka 内的核心概念：

- topic：作为 Kafka 内的顶级概念，无论是生产还是消费都需要指定 topic，一个 topic 代表一个消息队列
- partition：**为了保证扩展性，Kafka 会从逻辑上将一个 topic 分成多个 partition。**每次写入 topic 内的 message 会按照策略被分配到指定 partition。**每个 partition 内维护 message 的唯一 ID，即 offset**
- broker：无论是 topic 还是 partition 都是逻辑概念，最终都需要将数据存储到物理磁盘。Kafka 作为一个分布式集群服务，broker 是每个集群的的节点（物理机/集群），也是 message 最终写入磁盘的位置。**为了保证高可用，需要将多个 partition 写到不同的 broker 上**

1. Kafka 对生产者不做限制，只需指定 topic 等基础信息即可；
2. message 写入 topic 后，会将其分配到各个 partition，每个 partition 会管理自己的 offset（横向拓展），即通过 topic、partition 以及 offset 能够唯一确定指定 message；
3. Broker 是集群内的节点，用来存储 message，每个 broker 内均匀分布以 parition 为维度的数据（高可用）；由 Zookeeper 推选出 Broker Leader，它会管理 message 的读写，同时其他 broker （replication）向其进行同步，保证数据一致性；
4. 在 kafka 内支持两种消费模式：

- 队列模式：即每个 message 被均匀分配到不同的 consumer，这样消费效率很高
- pub/sub 模式：即订阅模式，每个 message 会被分配给所有已订阅该 topic 的 consumer，一条消息能被消费多次

5. kafka 内提出了 consumer group 的概念，用来综合使用以上两种消费模式，即一条 message 会被均匀分配到 consumer group 内（pub/sub），在其内部会以队列模式快速对消息进行消费，我们需要在初始化 kafka client 时，指定 group name;
6. kafka 会保证每个 partition 内的消息顺序，但是并不能保证全局的消息顺序；
7. consumer 实例与 partition 数量的关系：

- consumers == partitions，则一个消费者对应一个 partition
- consumers > partitions，则会存在 consumer 空跑
- consumers < partitions，则一个 consumer 节点消费多个 partition 的情况

在 Kafka 内，什么时候清除 message ?

从某种程度上，我们可以将 kafka 队列服务看作一个日志服务，partition 不会在指定时间之前删除消息。比如，你设置消息 7 天有效期，那么在这段时间内任意时刻，都可以通过 consumer 对消息进行消费，7 天后会自动删除。并且 partition 会记录每个 consumer group 的最新 offset。
