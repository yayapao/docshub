---
id: qs
title: ''
sidebar_label: 'React Questions'
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="Questions about React"
  description="对 React 生产问题的深度思考🤔。"
  tags={['React']}
  links={[
    {
      label: 'React 官网',
      link: 'https://zh-hans.react.dev/learn',
    },
    {
      label: 'Why does useRef solve the problem of stale state?',
      link: 'https://stackoverflow.com/questions/66622967/why-does-useref-solve-the-problem-of-stale-state',
    },
    {
      label: 'Rename A File With JavaScript In The Browser',
      link: 'https://pqina.nl/blog/rename-a-file-with-javascript/',
    },
    {
      label: 'react-fiber-architecture',
      link: 'https://github.com/acdlite/react-fiber-architecture',
    },
  ]}
/>

## 在 React 内如何处理文件对象？

:::warning Before we start

[File](https://developer.mozilla.org/en-US/docs/Web/API/File) 可以看作是 Blob 的一种特殊实现，因此它具备 Blob 的所有属性和方法，除此之外，它还 `name`, `lastModified` 以及 `webkitRelativePath` 等属性

**正是由于 File 的属性为 readonly，使我们在试图改变它时遇到麻烦。**

:::

本章节，我将基于 React 结合 [filepond](https://pqina.nl/filepond/docs/) 来介绍在现代框架内**处理上传文件的需求**，同时提供设计上传组件的思路和细节。

观察 filepond 我发现，它在处理文件上传时，支持：

- 在文件对象被发送到服务器之前，通过内置和自定义插件，更改文件对象，比如重命名、预览等操作
- 对于已上传文件，支持默认删除操作，会同时删除服务端和客户端文件对象

filepond 为了规避 File 对象的只读属性，采用了以下方案：

1. 当用户上传一个文件时，会产生一个只读的 File 对象；
2. filepond 插件基于原 File 对象，创建新的 File 对象来规避只读的限制；
3. 基于 File 对象生成本地 URL 来预览图片；
4. 服务端和客户端需要达成某种约定，即当上传成功后，将文件 ID 以约定形式返回，组件从结果内取出后放去内存，从而进行后续删除等操作；
5. 不同浏览器在处理 File 对象时，可能会将其转换为 Blob 对象，**服务端接收 Blob 对象后，会将其 filename 解析成 blob**。因此，需要确保上传数据为 File 对象；

### 如何在客户端对 File 对象进行重命名？

以重命名为例，当我们需要更改 File 的属性时，**目前标准的解决方案时，以原 File 对象为基础，生产一个新的 Blob 对象，并将其转换为 File 对象。**

_为什么不是直接生产 File 对象？_

- 不同浏览器对于 File 对象的处理存在差异
- `Blob.slice` 会返回一个 Blob 对象

```js
const renameFile = (file, name) => {
  // 新建一个 Blob 对象，指定开始/结束位置和数据类型，并为其重命名
  const renamedFile = file.slice(0, file.size, file.type)
  renamedFile.lastModifiedDate = file.lastModifiedDate
  renamedFile.name = name
  // 将 Blob 对象转换为 File
  const form = new FormData()
  form.set('file', renamedFile, name)
  return form.get('file')
}
```

### 如何实现本地预览文件？

这里特指浏览器可以打开的文件，比如 image/\*, SVG, 以及 PDF 等格式文件。

1. 通过 `window.URL.createObjectURL(file)` 方法，创建一个链接，将返回值放入 img.src 属性内；
2. 通过 `FileReader` 将文件内容转为 base64 格式，进行读取；

```js filereader
var fileReader = new FileReader()

reader.onload = function (e) {
  // base64 编码
  const res = e.target.result
}
reader.readAsDataURL(file)
```

## 为什么不建议向列表组件的头部插入数据？

在 React 内，向列表组件的头部和尾部插入数据，会产生比较明显的性能差异。原因在于 React 是依据 diff 算法来处理 DOM 更新。

React 会维护一份虚拟 DOM 树，当数据发生变化时，React 会根据新数据生成新的虚拟 DOM 树，并将其与旧的虚拟 DOM 树进行比较，找出需要更新的节点，然后更新 DOM。这个过程叫做 **协调（Reconciliation）**。

向尾部插入元素，React 会判定已存在的元素没有变化，只需要将新元素插入到尾部即可。

向头部插入元素，整个列表元素向后移动，如果此时 key 为 index 或者其他非唯一性的值，那么会导致整个列表重新渲染。

**因为，对于列表组件，如果我们考虑排序，或者表单的增删改，那么 key 必须唯一，且不建议向头部插入数据。**
