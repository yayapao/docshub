---
id: concept
title: Golang Concept
sidebar_label: concept
slug: concept
---

- Robert Griesemer（罗伯特-格利茨默）是 Google V8, Chubby, HotSpot JVM 主要贡献者
- Rob Pike 是 UNIX, UTF-8, plan9 的作者
- Ken Thompson 是 B 语言, C 语言的作者, UNIX 之父

**Go 的优势：**

1. 简单易学。
2. 自由高效。Go 的变异速度优于 JAVA 和 C++，同时拥有接近 C 的运行效率和接近 PHP 的开发效率
3. 强大的标准库
4. 部署方便。不使用虚拟机意味着，Go 应用可以直接输出为目标平台的二进制可执行文件
5. 原生并发支持。Go 的并发基于 Goroutine，成本更低，可以最大限度地使用 CPU 资源
6. 稳定性强。强大的编译检查，严格的编码规范，提供开发过程中各个生命周期的工具
7. 垃圾回收。Go 内置 runtime 来自动管理垃圾回收


## OOP

面向对象程序设计（`Object Oriented Programming`）是一种对现实世界进行理解和抽象的方法

 理解面向对象的关键点在理解：**属性和行为**

与其他编程语言一个较大的区别就是：其他编程语言大多使用关键字 `class` 来定义封装对象，但是 **Go 并不是一个纯面向对象的编程语言**，在 Go 内，采用更加灵活的结构体来代替类

结构体提供了捆绑数据和方法的行为，Go 虽然没有直接对于继承和多态的实现，但是可以通过匿名字段实现继承，通过接口实现多态，学习 Go 内的面向对象编程，一定要了解：

1. `struct` 结构体
2. `method` 方法
3. `interface` 接口

目前，我是这样理解的 `struct` 用来对应类中的属性（继承和封装的基础），`method` 和 `interface` 共同定义类的行为（多态的实现基础）



### Struct

Go 提供结构体来定义复杂的数据集合，结构体是由一系列相同类型或者不同类型的数据构成的数据集合

参考 [Y-lonelY/oop/struct](https://github.com/Y-lonelY/study-go/blob/master/oop/struct.go) 理解结构体的声明和使用方式

在使用结构体时，应该注意：

1. 在同一个包内，类型名不能重复，类型名用来唯一标识结构体
2. 结构体的属性，也叫字段，必须唯一
3. 同类型的成员属性可以写在一行

这里注意结构体的声明和使用区别：结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，这也意味着只有在定义结构体并且实例化之后才能使用结构体

**结构体是值类型，复制或者传递到函数体内都会重新分配内存**，基于此，我们可以思考一下结构体的深拷贝和浅拷贝：

- 如果结构体不是通过 `new()` 进行实例化，则复制/重新赋值都是深拷贝
- 要实现浅拷贝，可以通过 `new()` 来进行实例化或者对实例的地址进行复制



### Method

参考  [Y-lonelY/oop/method](https://github.com/Y-lonelY/study-go/blob/master/oop/method.go) 理解方法的声明方式和函数的区别 

Go 语言内同时有函数和方法，**方法的本质是函数**，但是它们又存在一些区别：

1. 含义不同。函数是一段独立功能的代码块，可以实现复用；方法用来表示一个类的行为功能，只有该类的对象才能调用
2. 方法有接受者，而函数没有。Go 内方法是一种作用于特定类型变量的函数，类似 JavaScript 中的 `this` 关键字
3. 函数不可以重名，而方法可以。只要接受者不同，方法名可以相同

Go 内在有函数的前提下，还要设计方法的实现，其原因不外乎：

- Go 不是一种纯粹面向对象的编程语言，它不支持类，因此方法意在实现类似于类的行为
- 相同名称的方法可以在不同类上进行定义，这一点很大程度区别于函数，比如你可以对不同形状的图形定义不同的求面积的方式

方法可以随着结构体继承而实现方法继承，即如果匿名字段实现了一个方法，那么包含这个匿名字段的 struct 也可以调用该匿名字段内的方法



### Interface

面向对象语言中，接口用于定义对象的行为。接口只指定对象应该做什么，实现这种行为的方式（实现细节）由对象自己决定

参考  [Y-lonelY/oop/interface](https://github.com/Y-lonelY/study-go/blob/master/oop/interface.go) 理解接口的声明和使用方式，以及和类的多态特性的联系 

`duck typing` 是描述事物的外部行为而不是内部结构，对于动态类型的语言来说，“一只鸟看起来像鸭子，那它就是鸭子”，反之，则归为静态类型语言，比如 Java

以 `Java` 为例，一个类必须显式地声明“类实现了某个接口”，然后这个接口才可以被使用，因此错误往往在编译时就被发现了。但是对于动态类型的语言来说，它并不要求一个类显式地声明它实现了某个接口。但是这样带来的缺陷也是显而易见的：**错误往往要在运行时才能被发现**

在 Go 内，采取了一个折中的办法：

1. 结构体类型 T 不需要显式地声明它实现了接口 I。只要类型 T 实现了接口 I 所规定的所有方法，它就自动实现了接口 I。这样就像动态语言一样省去了很多声明的代码，少了许多使用限制；
2. 将结构体类型的实例显式或者隐式地转换为接口 I 类型的实例 i，这样就可以像静态语言一样，在编译时检验其合法性



