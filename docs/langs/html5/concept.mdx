---
id: concept
title: HTML5 Concept
sidebar_label: concept
slug: concept
---

## Cache

当我们使用浏览器时，我们通常发现第一次进去会显得很慢，而再次进入则会“丝般顺滑”，打开控制台后，我发现了一些有趣的东西：再次加载资源时，其加载耗时和 size 都很大程度上减小。通过观察我们发现：

- 存在不同状态的 200，并且其资源的 size 值为 `from memory` 或者 `from disk`
- 部分资源请求返回 304 状态，即请求发送过去，服务器发现资源并没有发生变化，于是返回一个实体主体为空的响应报文

![reopen](/img/langs/html5/rerender.png)

这就是浏览器缓存机制引起的，浏览器缓存的基本元素包括：HTTP 缓存，indexDB，cookie，localStorage，sessionStorage

### HTTP 缓存

下图相关的是 <b>HTTP 缓存</b>，即通过 HTTP 首部行信息来管理缓存，结合下图来对 HTTP 缓存进行理解

![http-cache](/img/langs/html5/http-cache.png)

HTTP 缓存分为强缓存（cache-control）和协商缓存（e-tag, last_modified），其作用的简单流程：

1. 浏览器根据加载资源的 <b>http request 首部行信息</b>，即 cache-control（注意 expires 为 http1.0 的产物，这里不做讨论）字段来判断是否命中强缓存，如果命中则直接从缓存中加载资源，这个过程由浏览器主导；

2. 如果未命中强缓存，则会将资源请求发送至服务器，由服务器通过比对 `If-None-Match && ETag`, `If-Modified-Since && Last-Modified` 来判断本地缓存是否失效，如果可以使用，服务器会返回一个实体主体为空的响应报文，浏览器直接从缓存内加载资源；

3. 如果协商缓存也没有命中，则正常进行请求，服务器会返回资源信息和缓存标识，浏览器会加载资源并更新缓存；

---

<b>Q1: 如何判断是否命中强缓存？</b>

通过 HHTP1.1 的 Cache-Control 规则来进行判定，它含有多个指令，且其优先级高于 expires，对其进行一定了解

- `max-age=300` 表示 300s 进行重新请求资源，会命中强缓存
- `no-store` 不缓存任何资源
- `no-cache` 客户端仍然缓存资源，是否使用缓存则需要根据协商缓存的验证规则来决定
- `public` 表示浏览器和代理服务器都进行缓存
- `private` 表示仅浏览器对资源进行缓存

强缓存不会发 http 请求，比如上图中 status=200 且至灰的请求，可以看出从 memory cache 时延为 0ms，从 disk cache 时延差不多为 2ms

---

<b>Q2: 如何判断是否命中协商缓存?</b>

协商缓存需要进行 http 请求，主要由后端进行验证，参与的两个规则分别是 E-Tag 和 If-Modified-Since，如果返回 304，则表示服务器没有更新，直接从缓存内读取资源，否则返回 200，且从服务器加载资源

- 浏览器第一次请求一个资源的时候，服务器返回的 header 中会加上 Last-Modified，Last-Modified 是一个时间标识该资源的最后修改时间，之后再次请求该资源时，浏览器会在请求内添加 If-Modified-Since 字段，让服务器判断资源是否发生改变
- If-Modified-Since/Last-Modified <b>缺点在于其时间最小精度为秒，如果在很短时间内再次发生变化，则可能检测不到</b>
- 因此，E-Tag 提供了一种精度更高的判定方法，即为每个资源添加一个唯一标识，每次资源改变都会重新生成该标识，通过判断 If-None-match/E-Tag 来判断是否命中协商缓存
- E-Tag 优先级高于 Last-Modified

---

<b>Q3: 强缓存如何进行存储和读取?</b>

因为看到强缓存分为 disk cache 和 memory cache，且 disk cache 读取成本高于 memory cache，那么其区别在哪呢？

- 可以类比 sessionStorage 和 localStorage 来进行理解，disk cache 会将缓存放在磁盘中，memory cache 会放在内存中
- memory cache 更快，但是生命周期短，关闭页面就会释放，主要用来存放 js 文件，因为 js 文件经常要读取，css 文件可能只用读取一次
- disk cache 更慢，但是生命周期长，推测清除浏览器缓存时进行清理，通常在内存占用较高时存放文件，或者存放大文件和不常用的文件缓存
- memory cache 的读取优先级高于 disk cache

下面是一个简单的实现例子：

```javascript
const express = require("express");
const OSS = require("ali-oss");
const zlib = require("zlib");
const { URL } = require("url");
const path = require("path");
const MAX_AGE = 10; //单位秒
// 利用 OSS 缓存，参考：https://developer.alibaba.com/docs/doc.htm?treeId=620&articleId=116183&docType=1
const client = new OSS({...});

const app = express();
const port = 3000;

app.get("*", async (req, res) => {
  let u = req.url;
  if (req.headers.referer) {
    const uuu = new URL(req.headers.referer);
    const uuuu = path.join(uuu.pathname, "../../", u);
    u = uuuu;
  }
  //TODO html 文件不进行缓存

  // ------------------------------------------------
  /**
   *  缓存策略开始
   *  整体流程
   *  html 不进行缓存，只缓存资源文件
   *  请求的 if-none-match 进行比对，分为下面两种情况:
   *    1.  相等: 返回304，请求结束
   *    2.  不相等: 通过sdk获取资源，将头部 cache-control 和 etag写入，然后流式gzip然后返回数据
   *    cache-control 强制缓存时间暂定为1分钟
   */
  try {
    const gzip = zlib.createGzip();
    res.setHeader("cache-control", `max-age=${MAX_AGE}`); // MAX_AGE 时间为秒
    res.setHeader("Content-Encoding", "gzip");
    // 控制协商缓存
    // 如果要下载的文件太大，或者一次性下载耗时太长，您可以通过流式下载
    const result = await client.getStream(u, {
      headers: {
        "If-None-Match": req.headers["if-none-match"],
      },
    });
    res.setHeader("etag", result.res.headers["etag"]);
    res.statusCode = result.res.status;
    result.stream.pipe(gzip).pipe(res);
  } catch (e) {
    res.send("error"); // 抛错，注意获取
    res.end();
  }
});

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

## BrowserRouter

vue-router && react-router 内通过 h5.window.api 的方式来控制 url 和 ui 的同步（另一种方式是通过 hash 值来判断），用于 SPA，主要涉及的 API 为

- window.history
- window.onpopstate
- history.pushState(obj)
- history.replaceState(obj)

我理解一个可能的实现方案就是：通过配置好的渲染组件及路径，当用户操作导致路径改变时，会触发 `window.onpopstate` 事件，而该事件内通过事先定义好的方法，来实现相关元素重新渲染指定组件的效果，从而达到 SPA 的效果。与此类似，可以监听 `hashchange()` 方法来监听 hash 值的变化

### window.history

一个 **只读** 属性，用来保存浏览器的会话历史（浏览器地址栏中访问的页面，以及当前页面框架中加载的页面）

history 暴露的主要方法为：`back()`, `forward()`, `go()`，其用来控制在用户历史记录中的前后跳转

history 暴露的主要属性为：`length`, `fscrollRestoration`, `state`，其用来记录用户的历史记录相关信息

### window.onpopstate

每当处于激活状态的历史记录条目发生变化时，就会触发 `popstate` 事件

注意，不是地址栏发生变化就会触发，调用 `history.pushState()` 或者 `history.replaceState()` 不会触发 popstate 事件，其只会在某些浏览器行为下触发，比如 `back()`, `forward()`, `go()`

```javascript
// demo
window.onpopstate = function (event) {
  alert(
    'location: ' + document.location + ', state: ' + JSON.stringify(event.state)
  )
}
```

### history.pushState({ state, title, url })

向 history.state 内添加历史记录条目

- 当前地址栏发生变化，但是不会重新加载
- 不会触发 popstate 事件
- 一个特性就是，其可以改变 `XMLHttpRequest` 请求时的的 referer，并且不会改变当前页面内容

state 参数为一个 javascript 对象，`history.state` 内保存该对象
title（可选），state 的一个短标题
url 定义新的历史 url 记录，调用 pushState() 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。**新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理（感觉这里就是 SPA 的关键点）**

```javascript
history.pushState({ bar: 'bar' }, 'page 2', 'bar.html')
```

### history.replaceState({ state, title, url })

与 pushState 类似，区别在于 `replaceState()` 是修改了当前的历史记录项而不是新建一个，其使用场景在于为了响应用户行为，比如更新 history.state 或者当前历史记录的 url

## 渲染关键路径

浏览器接收到服务器封装并返回的字节数据，将其进行解析并转换为像素的过程被称为**渲染关键路径**

缩短浏览器页面渲染时间的一个思路就是缩短渲染关键路径

1. 处理 HTML 标记数据并生成 DOM 树

2. 处理 CSS 标记数据并生成 CSSOM 树

3. 将 DOM 树和 CSSOM 树合并生成渲染树

4. 遍历渲染树，计算每个节点的位置信息，进行布局

5. 将每个节点绘制到屏幕

以上的步骤是一个**渐进**的过程，为了提高用户体验，渲染引擎会试图更快呈现渲染结果，这意味着它不会等到所有的 HTML 文件都被解析完才创建并布局渲染树，它会将先获得的文档内容进行渲染（注意要生成渲染树）

DOM 树的构建过程是一个深度优先遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点

DOM（Document Object Model）文档对象模型，用来描述文档的结构与内容

CSSOM（Cascading Style Sheets Object Model）层叠样式表对象模型，用来描述对文档应用的样式规则

浏览器将字节数据解析成树结构（CSSOM 以及 DOM 树）的过程：字节数据(Bytes) > 语义化字符(Characters) > 令牌(Token) > 节点对象(Nodes) > 对象模型(DOM)

在 chrome 中可以利用开发者工具的 `performance > Event log` 来观察一个页面的渲染细节

想要渲染出页面，就需要将 DOM 树和 CSSOM 树结合起来，生成渲染树。浏览器会从 DOM 树的根节点开始遍历每个可见节点（注意`display:none`和`visibility:hidden`区别，前者不渲染，后者渲染），并找到其对应的 CSS 样式规则

结合盒子模型，计算每个节点在窗口内的确切位置和大小，也就是布局阶段，布局阶段输出的是一个盒子模型，它会精确捕获每个元素在屏幕内的确切位置和大小，所有相对的测量值也会被转换为屏幕内的绝对像素值

## 重绘和回流

结合渲染关键路径，理解重绘和回流

回流：当渲染树的一部分元素因为尺寸、布局、显隐等发生改变而需要重新构建。每个页面至少发生一次回流，因为页面第一次构建过程就是回流

重绘：当渲染树的一部分元素需要更新属性，这些属性仅仅影响元素的外观、风格，而不会影响布局

回流一定会发生重绘，而重绘不一定引起回流

注意：在隐藏元素时，`display: none;` 会引起回流和重绘，而 `visibilty: hidden;` 仅会引起重绘；另外，用户操作，比如缩放浏览器也会引起重绘和回流

过多的重绘和回流操作会影响浏览器的性能，一些针对性的优化办法：

- 通过 className 来一次性修改元素样式
- 添加元素时，将其封装好之后，一次性进行 append 操作
- 可以通过 `display:none;` 先隐藏元素，对其进行修改完毕之后，再将其展示

## 在浏览器输入 URL 的执行过程

URL 结构：

- scheme: 通信协议，比如 https 等
- host: 主机地址
- port: 端口号，用来标志进程
- path: 虚拟文件路径，说明资源位于服务器什么地方
- query: 查询参数
- hash: 信息片段字符串，锚点部分

明确一个概念，一个 URL 就是一个特定资源，该资源可能需要引用多个其他资源作为支撑

服务端交互获取渲染对象

- DNS 解析
- HTTP 请求（ TCP 三次握手，四次分手，请求/响应报文结构，Cookie，代理服务器）

通过浏览器渲染指定的资源文件

- 渲染关键路径
- 重绘和回流
