---
id: concept
title: JavaScript Concept
sidebar_label: concept
slug: concept
---

## 执行机制

:::note
JavaScript 是一门单线程语言，事件循环（Event Loop）是 JavaScript 的执行机制
:::

首先明白两个概念：

- 浏览器是多进程的
- JavaScript 引擎是单线程执行的

浏览器包含多个进程：

- Browser 进程：浏览器的主进程（负责协调、主控），只有一个，即用来管理浏览器
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU 进程：最多一个，用于 3D 绘制等
- 浏览器渲染进程（浏览器内核）（Renderer 进程，内部是多线程的）

浏览器渲染进程内就包含多个线程共同协作，完成渲染工作

- GUI 渲染线程，用来绘制渲染最短路径，与 js 引擎线程互斥，即两者只能同时运行一个
- js 引擎线程，负责解析，运行 js 脚本
- 事件触发线程，归属于浏览器，用来控制事件循环，可以理解为 js 引擎忙不过来了，需要启动该线程来协助
- 定时触发器线程，用来控制 setTimeout 和 setInterval，计时完毕后，将回调事件注册到事件触发线程内，等待 js 引擎线程去执行

由于 JavaScript 引擎是单线程机制，它无法同时执行多段代码，当一段代码执行的时候，所有后续任务必须等待，从而形成一个任务队列。一旦当前任务完成，再从队列中取出下一个任务执行，这也被称为 ‘阻塞式执行’

为什么 JavaScript 引擎被设计成阻塞式？

想象一个场景：如果 js 可以是多线程的，在同一个时间内，一段代码删除指定节点，一段代码修改这个节点，那么究竟应该怎样对这个节点做出何种改变，此时 js 引擎也无法作出判断

js 内函数异步执行的理解：

- 在当前位置调用了某个方法
- 但是在经过一段时间后才进行执行
- 即调整函数的执行顺序，并且保证该函数一定执行，就实现了异步的基本概念
- 从观察者的角度看，任务的完成顺序和交付它们的时间顺序无关
- 比如在发起一个 http 请求时，其回调函数一般也定义好了，但是不会立即执行该回调函数，而是会等待到请求的参数返回时才进行执行，这就是一个典型的异步
- 核心在于事件执行机制和消息队列

js 内常见的异步场景：

- 事件监听，比如`document.addEventListener('click', clickEvent)`等事件绑定
- 回调，比如 ajax 请求完成的回调，读取文件等
- 定时器任务，比如 `setTimeout`

![eventLoop](/img/langs/javascript/eventLoop.png)

`setTimeout()` 设置的延迟参数是从 EventTable 中注册回调函数到 EventQueue 的时延，所有**执行其回调函数的时延 >= 其设置的时延**

延迟实现

```js
function sleep(t) {
  var label = Date.now()

  while (Date.now() - label < t) {
    continue
  }
}
```

即使主线程执行栈为空，0ms 实际上也是达不到的，根据 HTML 标准，最低是 4ms

`setInterval()` 会每隔指定的时延将回调函数注册进入 EventQueue 中，一旦 `setInterval` 的回调函数的执行时间超过其设置的延迟，那么完全看不出来有时间间隔

除了广义的同步任务和异步任务，任务还有更加精细的定义

- macro-task(宏任务)：正常执行 script、setTimeout()、setInterval()
- mirco-task(微任务)：Promise、process.nextTick(类似 node.js 版的 setTimeout，其回调函数在事件循环的下一次循环中调用)

整体 script 作为第一个宏任务执行结束，会在 EventQueue 中检查还有哪些微任务，并对其依次执行（后进先出），至此完成第一次 EventLoop，然后再在 EventQueue 内检查宏任务，进行 EventLoop

总结来说，在 javascript 的事件循环内，优先级：同步任务，微任务，宏任务

```javascript
console.log('1') // 同步任务

// 整体作为一个异步任务
setTimeout(function () {
  console.log('5')
})

// 异步任务-微任务，在下一次循环内执行
process.nextTick(function () {
  console.log('3')
})

// 微任务-微任务
new Promise(function (resolve) {
  console.log('2')
  resolve()
}).then(function () {
  console.log('4')
})

// 输出结果
// 即 Promise > nextTick > Promise.then
1, 2, 3, 4, 5
```

## 执行环境

执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，当函数被调用时，会创建一个执行环境及相应的作用域链

当执行流进入一个函数时，函数的执行环境就会被推到一个环境栈中，当函数执行完毕之后，栈将其执行环境弹出，把控制权返回给之前的执行环境

执行环境组成

- 变量对象：每个执行环境都对应一个变量对象，我将这个变量对象理解为作用域，它用来保存执行环境中定义的所有变量和方法
- 作用域链：作用域链的本质是指向变量对象的指针列表，它只引用但不实际包含变量对象，作用域链用来保证对执行环境有权访问的所有变量和函数定义的有序访问
- this：指向当前执行环境

理论上，声明一个函数之后，就形成了一个作用域链，因为存在全局执行环境，其变量对象被认为是 window 对象。某个函数执行完毕之后，则该执行环境被销毁，其变量对象也同时销毁，全局执行环境直到应用程序退出（比如关闭浏览器或者网页）时才会被销毁

类似原型链，作用域链的标识符解析就是沿着作用域链一级一级搜索标识符的过程。**如果找不到指定标识符，会报 Reference Error，这点区别于原型链**

在 ES6 中，通过 `{}` 就能创建一个块级作用域，而之前则要通过 lamda 表达式结合闭包来进行创建

### 作用域链

作用域链怎么形成呢？

```js
function Person() {
  var a = '1'
  function Teddy() {
    console.log(a)
  }
  Teddy()
}

Person() // '1'
```

如上所示，定义了一个闭包，首先明确一定，存在全局作用域，其对象和方法存放在 winodw 对象内，ok，接下来解析作用域链怎么产生：

- 每个函数在定义时，都会产生一个 `[[scope]]` 属性，它就是作用域链，里面存放着对活动对象的引用，并且没有访问器属性，外界访问不到
- Person 方法定义时，会产生一个[[scope]]属性，其值为一个指向 window 对象的引用
- Person 调用时，会产生一个执行环境，同时向[[scope]]内添加一个指向当前（自身）活动对象的引用，并且此时定义 Teddy() 方法
- Teddy 方法定义时，会产生一个[[scope]]属性（可以看作是复制 Person 的该属性），里面存放着指向 Person 和全局的活动对象
- Teddy 方法调用时，会产生一个执行环境，同时向[[scope]]内添加一个指向当前（自身）活动对象的引用，所以当使用 a 时，会沿着作用域链向上寻找

### 闭包

闭包是指有权访问另一个函数作用域中的变量的函数，闭包的常见形式就是在一个函数内部创建一个函数。实际上，所有的 JavaScript 函数都是闭包

```javascript
function a() {
  var b = 1
  return (function () {
    return (b += 1)
  })()
}
var val = a()

// 通知垃圾回收进程将其清除
val = null
```

![scope](/img/langs/javascript/scope.png)

在创建 a() 函数前，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部 [[Scope]] 属性中

当调用 a() 时，会为函数创建一个执行环境，然后通过复制 [[Scope]] 属性构建其作用域链，并且创建当前执行环境的变量对象，并将其推入作用域链的前端

再对匿名函数进行调用时，会重复上述动作，此时 [[Scope]] 属性内，包含当前变量对象、a() 的变量对象以及全局变量对象的引用

在 a() 执行完毕之后，其作用域链会被销毁，但是其变量对象不会被销毁，仍然存在在内存中，因为匿名函数的作用域链仍然在引用这个变量对象

直到匿名函数被销毁时，a() 的变量对象才会被销毁，比如通过 `val = null` 的方式解除该函数的引用，通知垃圾回收进程将其清除

### 函数柯里化

函数柯里化通过一个例子来意会一下，它的基本思路和函数绑定是一样的，通过一个闭包来返回一个新的函数，实际上就是利用闭包来保存传参

例如将 `add(1,2,3)` 封装成 `add(1)(2)(3)`

```js
function add(x, y, z) {
  return x + y + z
}

function curry(fn, args) {
  var that = this
  var args = args ? args : []
  // len 表示原函数的形参个数
  var len = fn.length

  return function () {
    // 封装形参，因为arguments不是真正的数组，所以需要进行转换
    let newArr = Array.prototype.slice.apply(arguments)
    // 将之前的形参进行合并
    newArr = args.concat(newArr)
    // 判断是否为最后一个调用
    if (args.length < len) {
      // 如果不是，则将 add 继续传递
      return curry.call(that, fn, newArr)
    }
    // 如果是最后一项，则直接执行
    return fn.apply(that, newArr)
  }
}

var curryAdd = curry(add)
add(1)(2)(3) // 6
```

## this

JavaScript 中的 `this` 究竟是个什么东西？

我理解的 this，就是一个指针，指向一个对象，所以理解 this 的关键在于这个对象

先抛出一个结论：在 JavaScript 内，this 指向的对象会根据声明和调用方式的不同而改变，甚至和 js 是否启用严格模式有关

### 箭头函数

箭头函数用于解决函数内 this 指向不明确的情况，箭头函数在定义时就已经明确了 this 的指向

可以引申一下，在 react 内绑定事件的几种方式，一种是通过 `func.bind(this)` 来显示地将当前实例对象绑定到 func 上，即将其调用时的 this 指向当前实例对象，这样才能使用实例对象内的方法和属性，不然其 this 会指向触发事件的元素，而通过箭头函数声明的方法则不需要显示绑定，因为它调用时的 this 指向它声明时的 this，即当前实例对象

```js
// es6 之前版本
function Person() {
  this.a = 'a'
  this.b = {
    a: 'aaa',
    t: function () {
      return this.a
    },
  }
}

// 当调用 t() 方法时，this 指向其调用者，即 this === new Person().b，所以 this.a === 'aaa'
new Person().b.t() // 'aaa'

// es6 版本，对上面函数稍作修改
function Person() {
  this.a = 'a'
  this.b = {
    a: 'aaa',
    t: () => {
      return this.a
    },
  }
}

// 通过箭头函数声明的方法，其this指向是定义时this的指向，即在 new Person() 时 this 指向该 Person 的实例对象
// 因此 t() 在定义时 this 就指向其构造函数的实例
new Person().b.t() // 'a'
```

### 全局函数和对象内声明

在全局环境内声明一个函数，其 this 指向 window 对象，**如果是在严格模式下，则 this === undefined**，可以这么理解，test() 是全局环境内的一个方法，即 `window.test`，当调用时，其 this 指向其调用对象，即 window

```js
// ’use strict‘
function test() {
  console.log(this)
}
test() // 输出 Window 对象，严格模式下输出 undefined
```

同理，如果函数在对象内通过 function 进行声明，则 this 指向该对象，即 obj，但是如果通过箭头函数声明，其 this 还是会指向 window 对象

```js
var obj = {
  handler: function () {
    console.log(this)
  },
}
obj.handler()
```

### 元素的事件绑定

分为两种元素事件绑定：`addEventListener()` 和 `onclick()`，即一个 DOM 事件处理，一个内联事件处理

先看看第一种情况，作为 DOM 事件处理时，其 this 指向触发事件的元素，即 `<button id="btn">click</button>`，那么如果此时希望 this 是指向 obj 呢？

- 通过闭包来解决
- 通过`bind()`方法

```html
<body>
	<button id="btn">click</button>
</body>
</html>

<script type="text/javascript">
	var btn = document.querySelector('#btn');
	var obj = {
		handler: function() {
			console.log(this);
		}
	};
	btn.addEventListener('click', obj.handler);

	// 闭包解决
	btn.addEventListener('click', function() {
		// 在触发时，执行闭包函数，函数内执行obj.handler()，从而绑定this到obj
		obj.handler();
	});

	// bind() 显示将this指向obj
	btn.addEventListener('click', obj.handler.bind(obj));
</script>
```

第二种情况，通过内联事件处理来绑定事件，如下，此时 this 指向 obj，可以观察出一些东西，即 `()` 在其中扮演了一个重要的角色，`obj.handler()` 和 `obj.handler` 会造成其 this 的指向发生变化

```html
<body>
	<button id="btn" onclick="obj.handler()">click</button>
</body>
</html>

<script type="text/javascript">
	var obj = {
		handler: function() {
			console.log(this);
		}
	};
</script>
```

### bind

提到 this，就不得不说说 `bind()` 函数

`bind()` 方法会创建一个新的函数，其 `this` 被指定为 `bind()` 的第一个参数，其余参数作为新函数的参数

```js
// bind() polyfill
if (!Function.prototype.bind)
  (function () {
    // 保存 slice 方法，用于切割和拷贝 arguments
    var slice = Array.prototype.slice
    Function.prototype.bind = function () {
      var thatFunc = this,
        thatArg = arguments[0]
      var args = slice.call(arguments, 1)
      if (typeof thatFunc !== 'function') {
        throw new TypeError(
          'Function.prototype.bind - ' +
            'what is trying to be bound is not callable'
        )
      }
      return function () {
        var funcArgs = args.concat(slice.call(arguments))
        return thatFunc.apply(thatArg, funcArgs)
      }
    }
  })()
```

bind 方法和 call/apply 方法的区别在于

- bind 会返回一个新的函数，且不会自己调用
- call/apply 会在使用时调用一次

`call()` 和 `apply()` 也都是用来改变 this 指向对象，区别在于传参不同

- `call(newThis, params1, params2...)` 第一个参数为函数上下文对象，后面传入参数
- `apply(newThis, [params1, params2...])` 第一个参数为函数上下文对象，第二个参数为包裹传入参数的列表

```js
let obj = {
  name: 'ylone',
}

function test(age, job) {
  return [this.name, age, job]
}

// ['ylone', 26, 'engineer']
test.bind(obj, 26, 'engineer')()
test.apply(obj, [26, 'engineer'])
test.call(obj, 26, 'engineer')
```

### Array.prototype.slice.call(arguments)

在开发过程中，会发现经常会用到 `Array.prototype.slice.call(arguments)`，这一步实际上是对 arguments 进行拷贝，并且将其转换成为一个数组，看看下面的例子

其原理就是能将具有 length 属性的对象转成数组，常用的方法：

- `Array.prototype.slice.call(args)`
- `[].slice.call(args)`
- `Array.from(args)`
- 通过 for 循环进行 push 操作

```js
function test(a, b, c) {
  var args = arguments
  console.log(arguments.length) // 3
  console.log(Array.isArray(args)) // false
  console.log(typeof args) // object
  console.log(Object.prototype.toString.call(args)) // '[object Arguments]'

  // 通过 Array.from() 或者 Array.prototype.slice.call() 来将其转换为数组的数据类型
  var arr = Array.from(args)
  var arr = Array.prototype.slice.call(args)

  console.log(Array.isArray(arr)) // true
  console.log(typeof arr) // object
  console.log(Object.prototype.toString.call(arr)) // '[object Array]'
}
test(1, 2, 3)
```

## 对象

js 是一门面向对象的程序设计语言，因此对于对象的使用很常见，但是其一些高级特性应该了解一下

对象有两种属性：数据属性和访问器属性，且可以通过 `Object.getOwnPropertyDescriptor(object, property)` 来读取某个对象的属性配置

一点额外的知识点，为什么 Vue3.0 中会弃用 `Object.defineproperty` 而全面使用 `proxy()` 呢？

- `Object.defineproperty` 不能处理数组的变化，需要自己实现 polyfill
- `Object.defineproperty` 是对每个属性值进行绑定，而不能够监听整个对象，而这两点 proxy 能够解决

```js
// 利用 Object.defineProperty 来保护数据
var person = {};
Object.defineProperty(person, 'name', {
    _age: {
        // 能够 delete，重新定义等，该值一旦定义则不允许再进行更改
        configurable: true,
        // 能够通过for-in进行循环
        enumerable: true,
        // 能否修改属性值
        writable: true,
        // 设置属性值
        value: 26
    },
    /**
     * 设置访问器属性
     * 下划线是一种常用的记号，表示只能通过对象方法访问的属性
     */
    age: {
        get: function() {
            return this._age;
        }
        set: function(newValue) {
            this._age = newValue;
        }
    }
});

// 实际上等同于
var person = {
    _age: 26
};

// 获取对象特性描述
var des = Object.getOwnPropertyDescriptor(person, 'age');
//{value: 26, writable: true, enumerable: true, configurable: true}
```

### 数据保护

所谓数据保护，就是类似其他语言的 static 方法，保证某一个值不能够被修改，上面利用 Object.defineProperty 实现了一种方式，接下来介绍另外两种方式：

- 通过闭包进行保护
- 通过 ES6 proxy 特性进行保护
- `Object.seal()`方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变

```js
// 利用闭包
function Person() {
  var obj = {
    name: 'hello',
  }
  this.get = function (key) {
    return obj[key]
  }
  this.set = function (key, value) {
    throw new Error('cannot change')
  }
}
var person = new Person().set(name, 'world') // Uncaught Error: cannot change

// 利用 proxy
var obj = {
  name: 'hello',
  age: 10,
}
// 相当于对 obj 做了一层代理，返回为 person
var person = new Proxy(obj, {
  get(target, key) {
    return target[key]
  },
  set(target, key, value) {
    if (key === 'name') {
      throw new Error('cannot change')
    }
  },
})

// 但是如果此时直接更改 obj，不会报错，且会改变 person 的属性值
person.name = 'world' // Uncaught Error: cannot change
```

### 创建对象的模式

> 创建单个对象可以使用 Object 的构造函数`Object()`或者对象字面量`{}`来进行创建，但是如果需要创建多个对象时，往往通过函数来进行创建

#### 工厂模式

很直观，通过函数封住了创建对象的细节，并将其返回，存在一个很严重的问题，即我不能识别这个被创建的实例对象是什么类型

```js
function createObject(name) {
  var obj = {}
  obj.name = name
  return obj
}

var person = createObject('ylone')
```

#### 构造函数模式

通过构造函数来创建特定类型的对象，通过 new 操作符来创建实例，缺点就是如果对象内需要定义很多的方法，那么会污染全局，没有封装性

new 在这里的作用

- 创建一个新对象 `var obj = new Object()`
- 将构造函数的作用域赋值给新对象，因此 this 指向该新对象 `Person.call(this, name)`
- 执行构造函数内的代码，为这个新对象添加属性
- 返回新对象 `return obj`

```js
function Person(name) {
  this.name = name
  this.sayName = sayName
}

function sayName() {
  console.log(this.name)
}

var person = new Person('ylone')

person.constructor === Person // true
```

#### 原型模式

原型用来保存所有特定类型的实例所共享的属性和方法，因此 `sayName` 不用定义在全局，定义在原型对象上即可，这种模式的问题在于

- 如果其构造函数的原型属性被改变，那么所有实例都会被影响
- 如果构造函数的原型属性某一项值为引用数据，那么在实例上的改变也会影响该构造函数，从而影响所有的实例

```js
function Person() {}

Person.prototype.name = ''
Person.prototype.sayName = function () {
  console.log(this.name)
}

/**
 * 另一种写法不推荐，因为这样相当于重写了整个 prototype 属性，同时改变了其 constructor 指向，更改后指向了 Object
 */
Person.prototype = {
  name: '',
}

var person = new Person()
person.name = 'ylone'
```

#### 构造函数和原型组合使用

一个认可度比较高的模式，将构造函数内的属性视为各个实例对象的独立部分，将定义在原型上的属性和方法视为各个实例对象的公共部分

```js
function Person(name) {
  this.name = name
}
Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person('ylone')
```

## 对象继承

### 原型链

`prototype` 属性的本质是一个指针，指向一个对象，而这个对象包含特定类型的实例所能够共享的属性和方法

`__proto__` 是一个访问器属性，它是一个指针，指向构造函数的原型对象

两者区别在于：

- `prototype` 为构造函数的属性
- `__proto__` 为实例属性

实际上，可以将 `Super.prototype` 看作一个 Super 实例，即 `new Super()`

原型链搜索机制：当使用一个属性时，首先在当前实例内搜索该属性，如果没有找到，则继续搜索实例的原型，沿着原型链一直向上寻找，**如果在原型链中找不到一个属性时，会返回 undefined，这点区别于作用域链**

所有的函数其组件原型都是 Object，因此所有对象实例都能够使用 `.toString()` 来判断类型，全局定义函数的 `__proto__` 都等于 `Object.prototype`

原型链的顶端：因为 `Object.prototype.__proto__ === null` 因此，可以说 null 才是原型链真正的顶端，那么 undefined 可以认为是从 null 中进行抛出

```js
/**
 * SuperClass 为构造函数
 * 每个构造函数都有一个原型对象：SuperClass.prototype
 */
function SuperClass() {
  // statement
}

// 每个原型对象内都包含一个指向构造函数(即本身)的指针：SuperClass.prototype.constructor
SuperClass === SuperClass.prototype.constructor // true

/**
 * 所有的引用类型都默认继承 Object，即所有的函数默认原型都是 Object 对象
 * 这就是所有自定义的函数都可以使用 `toString()` 等方法的根本原因
 */
SuperClass.prototype.__proto__ === Object.prototype // true

/**
 * superInstance 为实例对象
 * 每个实例对象都包含一个指向其构造函数的原型对象的内部指针：superInstance.__proto__
 */
let superInstance = new SuperClass()

superInstance.__proto__ === SuperClass.prototype // true

superInstance.constructor === SuperClass // true
```

### 原型链继承

如果一个构造函数的原型重新赋值为一个实例对象，则构成原型链，这种的坏处，或者说整个原型链的劣势在于，如果其原型某一个属性为引用类型的值，一旦其值被改变，会影响整个原型链生态，从而影响所有实例

```js
// 父类
function SupClass() {
  this.age = [1, 2, 3]
}

// 子类
function SubClass() {
  // statement
}

/**
 * 实现的本质是重写原型对象，代之以一个新类型的实例，即原本存在于 SuperClass 实例内的属性和方法
 * SuperClass 的实例拥有其原型内共享的属性和方法，因此，通过赋值操作，现在也存在于 SubClass.prototype 内
 * 可以看作 SubClass.prototype = SupClass.prototype
 */
SubClass.prototype = new SuperClass()

let subInstance = new SubClass()
subInstance.age.push(4) // [1,2,3,4]

// 确定实例对象和构造函数之间的关系
Object.prototype.isPrototypeOf(subInstance) // true

// 返回实例的__proto__属性的值，即原型对象
Object.getPrototypeOf(subInstance) // SubClass.prototype

// 判断一个属性是在实例本身还是其原型链上，也可以通过 in 操作符来实现
subInstance.hasOwnProperty(age) // false
```

### 组合继承

```js
// 父类
function SupClass() {
  this.age = [1, 2, 3]
}

// 子类
function SubClass(name) {
  SupClass.call(this)
  this.name = name
}

SubClass.prototype = new SupClass()
SubClass.prototype.constructor = SupClass
```
