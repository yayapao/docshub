---
id: grammar
title: Grammar
sidebar_label: grammar
slug: grammar
---

## 变量提升

理解一个关键概念：**暂存死区**

- `var`声明被置于函数作用域的顶部，但是它们的赋值不是
- `const`和`let`在块作用域中，会被置于块头部的暂存死区，直至它们被初始化，在这期间，如果变量被访问（比如 typeof ），会直接抛出 ReferenceError 错误

```javascript
function test() {
  console.log(a) // => throws a ReferenceError
  console.log(b) // => undefined
  var b = 100
  console.log(c) // => throws a ReferenceError
  const c = 100
  let d
  console.log(d) // => undefined
  d = 100
}
```

## Array

> Array 对象是类似于列表的高阶对象，是在 JavaScript 内用于构造数组的全局对象

Array 是一组有序列表，与其他语言相比，JavaScript 内数组可以存放人意类型的数据，且数组大小可以动态调整

关注数组支持的方法，其实现效果，返回值，以及是否修改原数组

会修改原数组的方法（即指向同一引用）：`Array.pop()`, `Array.shift()`, `Array.push()`, `Array.unshift()`, `Array.reverse()`

返回一个新数组的方法（即指向不同引用）：`from()`, `map()`

### map() && async/await

将 `map()` 和 `async/await` 结合起来使用会有一点复杂，关键在于 `Promise.all()` 方法

```js
const list = ['request1', 'request2', 'request3']
// 单个异步请求
const anAsyncFunction = async (data) => {
  return await request(data)
}

// 组合异步请求
const getData = async () => {
  return Promise.all(list.map((item) => anAsyncFunction(item)))
}
// 捕获所有异步请求的请求数据
const data = await getData()
```

### 聊聊 foreach

foreach 是遍历数组的一个常用方法，但是其有一个特性很容易引起错误

- 在 foreach 循环内，只能通过抛出异常能够跳出整个循环
- 在 foreach 可以通过 return 来跳出当前循环，执行下一次循环
- 在 foreach 内如果使用 break,continue 会直接抛出错误，即它们只能在可迭代语句内使用，在函数内使用会报语法错误

```js
var a = [1, 2, 3, 4, 5]
a.forEach((item) => {
  if (item === 3) {
    // Uncaught SyntaxError: Illegal break statement
    break
    // Uncaught SyntaxError: Illegal continue statement: no surrounding iteration statement
    continue

    return false // 1,2,4,5

    throw new Error('jump') // 1,2，但是会抛出一个自定义错误
  }
  console.log(item)
})
```

另外，foreach 是按照 index 来进行遍历的，forEach 不会在迭代之前创建数组的副本，这意味着如果在遍历过程中添加或者删除，会影响其他元素的行为，所以不要在 foreach 内任意修改数组

```js
// 如果数组在迭代时被修改了，则其他元素会被跳过
var words = ['one', 'two', 'three', 'four']
words.forEach(function (word) {
  console.log(word)
  if (word === 'two') {
    words.shift()
  }
}) // -> 'one' 'two' 'four'
```

### 初始化数组

```javascript
/**
 * 通过数组声明
 * 1. 可以通过 new Array() 来声明，其中 new 可以省略
 * 2. 更加常用的方法是通过 [] 操作符来声明
 * 3. ES6 提供 Array.of() 方法来声明数组
 */
let arr1 = new Array() || new Array(10) || new Array("a", "b", "c")
let arr2 = ["a", "b", "c"]
let arr3 = Array.of("a", 1) -> ["a", 1]

/**
 * Array.from()
 * 将 array-like 和 interable 对象(比如字符串)转换为数组
 *  array-like 要求很严格，必须key为从0开始的数字，且包含length属性
 * 常用在 DOMNodeList 来生成可遍历对象
 */
let pList = Array.from(document.querySelectorAll("p")); ->[p,...]
let strList = Array.from("123") -> ["1", "2", "3"]

/**
 * Array.fill()
 * 通过指定值来填充一个数组，原数组会被重新赋值，但是保持其数组长度不变
 */
arr2.fill(1) -> [1, 1, 1]
```

### 数组常用的操作方法

```javascript
/**
 * 通过索引访问数组
 * 在 JavaScript 中，以数字开头的属性不能用点号引用，必须用方括号
 * 下面的方法以 arr2 最为初始化对象
 */
let arr2 = ["a", "b", "c"]
arr2[arr2.length - 1] -> "c"

/**
 * 删除元素
 * pop() 删除最后一个元素，返回被删除元素的值，直接修改原数组
 * shift() 删除第一个元素，返回被删除元素的值，直接修改原数组
 * splice(start, nums) 来删除指定位置的元素，返回删除元素的数组，直接修改原数组
 */
arr2.pop() -> "c"
arr2.shift() -> "a"
// indexOf() 获取指定元素位置，返回一个Int类型
const index = arr.indexOf("a") -> 0
// 示从 index 开始，向后删除 1 个元素
arr2.splice(index, 1) -> ["a"]

/**
 * 添加元素
 * push() 在数组最后位置添加元素，返回添加元素后的数组长度，直接修改原数组
 * unshift() 在数组第一项前添加元素，返回添加元素后的数组长度，直接修改原数组
 */
arr2.push("d") -> 4
arr2.unshift("d") -> 4

/**
 * 截取数组
 * 如果是从数组开始位置进行截取，可以直接重新复制length来实现截取，返回新的数组长度，直接修改原数组
 */
arr2.length = 1 -> 1
```

使用 `arr1.push.apply(arr1, arr2)` 来合并数组，可以减少内存消耗，`arr1.concat(arr2)` 会创建一个新的数组并消耗内存

### 遍历

foreach 是遍历数组的一个常用方法，但是其有一个特性很容易引起错误：即在 `foreach` 循环内，只能通过抛出异常能够跳出循环

如果需要跳出循环，其替代方法：

- 简单循环
- `for...of` 循环
- `Array.prototype.every()`
- `Array.prototype.some()`
- `Array.prototype.find()`
- `Array.prototype.findIndex()`

foreach 是按照 index 来进行遍历的，forEach 不会在迭代之前创建数组的副本，这意味着如果在遍历过程中添加或者删除，会影响其他元素的行为

```js
// 如果数组在迭代时被修改了，则其他元素会被跳过
var words = ['one', 'two', 'three', 'four']
words.forEach(function (word) {
  console.log(word)
  if (word === 'two') {
    words.shift()
  }
}) // -> 'one' 'two' 'four'
```

## class

在 ES6 中，通过 `class` 定义一个类的时候，其通过 `constructor` 构造方法内定义的属性和方法是实例对象自己的，而 `constructor` 外定义的方法和属性则是所有实例对象可以共享的

### super 关键字

ES6 中 `super` 关键字有两种存在形式：

1. 作为函数，即 `super()`

通过 `super()` 调用，super() 代表父类的构造函数，但是其内部 this 指向当前子类实例

这是因为子类本身不具有 this 对象，而是继承父类的 this 对象，然后对其进行加工，如果不调用 `super()`，子类就无法得到 this 对象

ES6 的继承机制，实质上是先创造父类的实例对象 this，然后再用子类的构造函数修改 this

注意：子类的构造函数内必须调用一次 super()，且只能在 constructor() 内调用

```js
// new.target 指向当前正在执行的函数
class A {
  constructor() {
    console.log(new.target.name)
  }
}
class B extends A {
  constructor() {
    super()
  }
}
new A() // A
new B() // B
```

2. 作为对象，即 `super`，在普通方法内，指向父类的原型对象（即 `SuperClass.prototype`，可以结合 swift 内 super 来理解，访问超类的方法，属性和下标），在静态方法内，指向父类（即 `SuperClass`）

在子类普通方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类实例

```js
class A {
  constructor() {
    this.x = 1
  }
  print() {
    console.log(this.x)
  }
}

class B extends A {
  constructor() {
    super()
    this.x = 2
  }
  m() {
    super.print()
  }
}

let b = new B()
b.m() // 2
```

## import && export

ES6 Module 用来解决模块化的问题，将一个大文件拆分成互相依赖的小文件，再将其进行拼接

ES6 之前的 `require` 方法和 ES6 的 `module` 简单比较

**before ES6 -- require**

- `require` 是**运行时加载**，获取的是值的拷贝，这意味着一旦 require 成功，模块更改也不会影响已经 require 的模块
- require 方式获取值，在 class 内外都可以拿到值

**ES6 -- module**

- `module` 是**编译时加载**（或者说静态加载），ES6 可以在编译时就完成模块的加载，效率更高，获取的是文件
- import 方式获取值，在 class 外调值为 undefined，在 class 内调用能够正常拿到值，因为在实例化类的时候，才会去调用这个 import modul

  e

- `export` 的本质是在接口名和内部变量之间建立一一对应关系

## Promise

什么是 Promise ?

- Promise 主要用于异步计算
- 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
- 简单来讲，Promise 就是一个容器，里面保存着未来某个时间点才会结束的事件

promise 的状态：

- 实例话 Promise 对象时，是 pending 状态
- 执行完后调用 resolve()，是 fulfilled 状态
- 执行完后调用 reject()，是 rejected 状态

当 promise 状态发生改变，就会触发 `.then()` 内的响应函数来处理后续步骤，并且只有异步操作的结果可以唯一决定当初对象的状态，其他操作都不能改变这个状态，且任何时候都能得到这个结果（这意味着可以通过一个变量来保存当前 Promise 实例，之后可以在任意时刻再通过 `.then` 进行处理）

```js
// 基本写法
new Promise(
  // 执行器
  function (resolve, reject) {
    // 执行一个耗时很久的异步操作

    // 事件处理完成
    resolve(data)
    // 事件处理出错
    reject()
  }
).then(
  function (data) {
    // 成功
  },
  function () {
    // 错误
  }
)
```

Promise 时如何优化回调地狱的？

- 所谓回调地狱是指，函数一层一层嵌套，将函数作为参数和返回值进行传递

可以看到，第一个 then 方法内 return 了一个新的 Promise 对象，形成链式结构

```js
new Promise((resolve) => {
  setTimeout(function () {
    resolve('hello')
  }, 2000)
})
  .then((data) => {
    console.log(data)
    return new Promise((resolve) => {
      setTimeout(function () {
        resolve('world')
      }, 2000)
    })
  })
  .then((data) => {
    console.log(data)
  })
// hello world
```

`.then()` 函数：

- 接受两个参数，分别对应 fulfilled 和 rejected 状态
- 返回一个新的 promise 对象，因此可以链式调用
- 当新的 Promise 状态发生改变时，.then 会根据新 Promise 其最终状态进行执行
- 如果返回其他值（即不是 Promise，直接 return），则下一个 `.then()` 会立即执行
- 尽量不要在 `.then()` 内再去嵌套 then() 方法，直接展开，这样阅读体验更好

针对 Promise 的错误捕获

- 两种方式都可以进行捕获到 `rejected` 状态，一种是通过 `.then()` 传入两个函数，一种是通过 `.catch()` 方法
- catch() 方法也会返回一个 Promise 对象，最好在最后都添加一个 catch() 方法，因为它可以捕获到链路上发生的错误，即如果 then() 内发生了错误，它也可以捕获到

```js
new Promise((resolve) => {
  setTimeout(() => {
    resolve()
  }, 1000)
})
  .then(() => {
    throw new Error('error!')
  })
  // 当前 then() 会被跳过而直接执行 catch()，因为上一个 Promise 状态被置为 rejected
  .then(() => {
    console.log('hello')
  })
  .catch((err) => {
    console.log(err)
  })
// Error: error!
```

`Promise.all(array)` 用于封装多个 promise(当然也可以是其他同步方法，会立即执行)，等待都执行完毕，发生状态改变后，返回一个新的 promise 对象

- 如果所有方法执行成功，返回一个包含各个方法结果的数组
- 如果发生了错误，则返回第一个错误发生时的 error
- 通常和 `map()` 连用

```js
let arr = [f1, f2, f3]

Promise.all(
  arr.map((item) => {
    return new Promise(item)
  })
).then((arr) => {
  // statement
})
```

## 对象

js 是一门面向对象的程序设计语言，因此对于对象的使用很常见，但是其一些高级特性应该了解一下

对象有两种属性：数据属性和访问器属性，且可以通过 `Object.getOwnPropertyDescriptor(object, property)` 来读取某个对象的属性配置

一点额外的知识点，为什么 Vue3.0 中会弃用 `Object.defineproperty` 而全面使用 `proxy()` 呢？

- `Object.defineproperty` 不能处理数组的变化，需要自己实现 polyfill
- `Object.defineproperty` 是对每个属性值进行绑定，而不能够监听整个对象，而这两点 proxy 能够解决

```js
// 利用 Object.defineProperty 来保护数据
var person = {};
Object.defineProperty(person, 'name', {
    _age: {
        // 能够 delete，重新定义等，该值一旦定义则不允许再进行更改
        configurable: true,
        // 能够通过for-in进行循环
        enumerable: true,
        // 能否修改属性值
        writable: true,
        // 设置属性值
        value: 26
    },
    /**
     * 设置访问器属性
     * 下划线是一种常用的记号，表示只能通过对象方法访问的属性
     */
    age: {
        get: function() {
            return this._age;
        }
        set: function(newValue) {
            this._age = newValue;
        }
    }
});

// 实际上等同于
var person = {
    _age: 26
};

// 获取对象特性描述
var des = Object.getOwnPropertyDescriptor(person, 'age');
//{value: 26, writable: true, enumerable: true, configurable: true}
```

### 数据保护

所谓数据保护，就是类似其他语言的 static 方法，保证某一个值不能够被修改，上面利用 Object.defineProperty 实现了一种方式，接下来介绍另外两种方式：

- 通过闭包进行保护
- 通过 ES6 proxy 特性进行保护
- `Object.seal()`方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变

```js
// 利用闭包
function Person() {
  var obj = {
    name: 'hello',
  }
  this.get = function (key) {
    return obj[key]
  }
  this.set = function (key, value) {
    throw new Error('cannot change')
  }
}
var person = new Person().set(name, 'world') // Uncaught Error: cannot change

// 利用 proxy
var obj = {
  name: 'hello',
  age: 10,
}
// 相当于对 obj 做了一层代理，返回为 person
var person = new Proxy(obj, {
  get(target, key) {
    return target[key]
  },
  set(target, key, value) {
    if (key === 'name') {
      throw new Error('cannot change')
    }
  },
})

// 但是如果此时直接更改 obj，不会报错，且会改变 person 的属性值
person.name = 'world' // Uncaught Error: cannot change
```

### 创建对象的模式

> 创建单个对象可以使用 Object 的构造函数`Object()`或者对象字面量`{}`来进行创建，但是如果需要创建多个对象时，往往通过函数来进行创建

#### 工厂模式

很直观，通过函数封住了创建对象的细节，并将其返回，存在一个很严重的问题，即我不能识别这个被创建的实例对象是什么类型

```js
function createObject(name) {
  var obj = {}
  obj.name = name
  return obj
}

var person = createObject('ylone')
```

#### 构造函数模式

通过构造函数来创建特定类型的对象，通过 new 操作符来创建实例，缺点就是如果对象内需要定义很多的方法，那么会污染全局，没有封装性

new 在这里的作用

- 创建一个新对象 `var obj = new Object()`
- 将构造函数的作用域赋值给新对象，因此 this 指向该新对象 `Person.call(this, name)`
- 执行构造函数内的代码，为这个新对象添加属性
- 返回新对象 `return obj`

```js
function Person(name) {
  this.name = name
  this.sayName = sayName
}

function sayName() {
  console.log(this.name)
}

var person = new Person('ylone')

person.constructor === Person // true
```

#### 原型模式

原型用来保存所有特定类型的实例所共享的属性和方法，因此 `sayName` 不用定义在全局，定义在原型对象上即可，这种模式的问题在于

- 如果其构造函数的原型属性被改变，那么所有实例都会被影响
- 如果构造函数的原型属性某一项值为引用数据，那么在实例上的改变也会影响该构造函数，从而影响所有的实例

```js
function Person() {}

Person.prototype.name = ''
Person.prototype.sayName = function () {
  console.log(this.name)
}

/**
 * 另一种写法不推荐，因为这样相当于重写了整个 prototype 属性，同时改变了其 constructor 指向，更改后指向了 Object
 */
Person.prototype = {
  name: '',
}

var person = new Person()
person.name = 'ylone'
```

#### 构造函数和原型组合使用

一个认可度比较高的模式，将构造函数内的属性视为各个实例对象的独立部分，将定义在原型上的属性和方法视为各个实例对象的公共部分

```js
function Person(name) {
  this.name = name
}
Person.prototype.sayName = function () {
  console.log(this.name)
}

var person = new Person('ylone')
```

## this

JavaScript 中的 `this` 究竟是个什么东西？

我理解的 this，就是一个指针，指向一个对象，所以理解 this 的关键在于这个对象

先抛出一个结论：在 JavaScript 内，this 指向的对象会根据声明和调用方式的不同而改变，甚至和 js 是否启用严格模式有关

### 箭头函数

箭头函数用于解决函数内 this 指向不明确的情况，箭头函数在定义时就已经明确了 this 的指向

可以引申一下，在 react 内绑定事件的几种方式，一种是通过 `func.bind(this)` 来显示地将当前实例对象绑定到 func 上，即将其调用时的 this 指向当前实例对象，这样才能使用实例对象内的方法和属性，不然其 this 会指向触发事件的元素，而通过箭头函数声明的方法则不需要显示绑定，因为它调用时的 this 指向它声明时的 this，即当前实例对象

```js
// es6 之前版本
function Person() {
  this.a = 'a'
  this.b = {
    a: 'aaa',
    t: function () {
      return this.a
    },
  }
}

// 当调用 t() 方法时，this 指向其调用者，即 this === new Person().b，所以 this.a === 'aaa'
new Person().b.t() // 'aaa'

// es6 版本，对上面函数稍作修改
function Person() {
  this.a = 'a'
  this.b = {
    a: 'aaa',
    t: () => {
      return this.a
    },
  }
}

// 通过箭头函数声明的方法，其this指向是定义时this的指向，即在 new Person() 时 this 指向该 Person 的实例对象
// 因此 t() 在定义时 this 就指向其构造函数的实例
new Person().b.t() // 'a'
```

### 全局函数和对象内声明

在全局环境内声明一个函数，其 this 指向 window 对象，**如果是在严格模式下，则 this === undefined**，可以这么理解，test() 是全局环境内的一个方法，即 `window.test`，当调用时，其 this 指向其调用对象，即 window

```js
// ’use strict‘
function test() {
  console.log(this)
}
test() // 输出 Window 对象，严格模式下输出 undefined
```

同理，如果函数在对象内通过 function 进行声明，则 this 指向该对象，即 obj，但是如果通过箭头函数声明，其 this 还是会指向 window 对象

```js
var obj = {
  handler: function () {
    console.log(this)
  },
}
obj.handler()
```

### 元素的事件绑定

分为两种元素事件绑定：`addEventListener()` 和 `onclick()`，即一个 DOM 事件处理，一个内联事件处理

先看看第一种情况，作为 DOM 事件处理时，其 this 指向触发事件的元素，即 `<button id="btn">click</button>`，那么如果此时希望 this 是指向 obj 呢？

- 通过闭包来解决
- 通过`bind()`方法

```html
<body>
	<button id="btn">click</button>
</body>
</html>

<script type="text/javascript">
	var btn = document.querySelector('#btn');
	var obj = {
		handler: function() {
			console.log(this);
		}
	};
	btn.addEventListener('click', obj.handler);

	// 闭包解决
	btn.addEventListener('click', function() {
		// 在触发时，执行闭包函数，函数内执行obj.handler()，从而绑定this到obj
		obj.handler();
	});

	// bind() 显示将this指向obj
	btn.addEventListener('click', obj.handler.bind(obj));
</script>
```

第二种情况，通过内联事件处理来绑定事件，如下，此时 this 指向 obj，可以观察出一些东西，即 `()` 在其中扮演了一个重要的角色，`obj.handler()` 和 `obj.handler` 会造成其 this 的指向发生变化

```html
<body>
	<button id="btn" onclick="obj.handler()">click</button>
</body>
</html>

<script type="text/javascript">
	var obj = {
		handler: function() {
			console.log(this);
		}
	};
</script>
```

### bind

提到 this，就不得不说说 `bind()` 函数

`bind()` 方法会创建一个新的函数，其 `this` 被指定为 `bind()` 的第一个参数，其余参数作为新函数的参数

```js
// bind() polyfill
if (!Function.prototype.bind)
  (function () {
    // 保存 slice 方法，用于切割和拷贝 arguments
    var slice = Array.prototype.slice
    Function.prototype.bind = function () {
      var thatFunc = this,
        thatArg = arguments[0]
      var args = slice.call(arguments, 1)
      if (typeof thatFunc !== 'function') {
        throw new TypeError(
          'Function.prototype.bind - ' +
            'what is trying to be bound is not callable'
        )
      }
      return function () {
        var funcArgs = args.concat(slice.call(arguments))
        return thatFunc.apply(thatArg, funcArgs)
      }
    }
  })()
```

bind 方法和 call/apply 方法的区别在于

- bind 会返回一个新的函数，且不会自己调用
- call/apply 会在使用时调用一次

`call()` 和 `apply()` 也都是用来改变 this 指向对象，区别在于传参不同

- `call(newThis, params1, params2...)` 第一个参数为函数上下文对象，后面传入参数
- `apply(newThis, [params1, params2...])` 第一个参数为函数上下文对象，第二个参数为包裹传入参数的列表

```js
let obj = {
  name: 'ylone',
}

function test(age, job) {
  return [this.name, age, job]
}

// ['ylone', 26, 'engineer']
test.bind(obj, 26, 'engineer')()
test.apply(obj, [26, 'engineer'])
test.call(obj, 26, 'engineer')
```

### Array.prototype.slice.call(arguments)

在开发过程中，会发现经常会用到 `Array.prototype.slice.call(arguments)`，这一步实际上是对 arguments 进行拷贝，并且将其转换成为一个数组，看看下面的例子

其原理就是能将具有 length 属性的对象转成数组，常用的方法：

- `Array.prototype.slice.call(args)`
- `[].slice.call(args)`
- `Array.from(args)`
- 通过 for 循环进行 push 操作

```js
function test(a, b, c) {
  var args = arguments
  console.log(arguments.length) // 3
  console.log(Array.isArray(args)) // false
  console.log(typeof args) // object
  console.log(Object.prototype.toString.call(args)) // '[object Arguments]'

  // 通过 Array.from() 或者 Array.prototype.slice.call() 来将其转换为数组的数据类型
  var arr = Array.from(args)
  var arr = Array.prototype.slice.call(args)

  console.log(Array.isArray(arr)) // true
  console.log(typeof arr) // object
  console.log(Object.prototype.toString.call(arr)) // '[object Array]'
}
test(1, 2, 3)
```
