---
id: concept
title: Python3 Concept
sidebar_label: concept
slug: concept
---

## 面向对象编程

面向对象中需要重点理解两个东西：类（class）和实例（instance）

就比如：人是一个 class，人具有年龄，爱好等属性，同时人可以制造工具或者进行其他活动，这可以视为人的属性和方法，而地球上的每一个人就是人这个类的 instance

类是抽象的模版，实例是类的具体表现

面向对象的**核心思想**是抽象出 class，再利用 class 创建出 instance

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'wakatime scripts'

__author__ = 'Y-lonelY'

import json
import requests

class Person(object):
	# 普通成员变量
	url = 'https://wakatime.com/api/v1/users/current/summaries'
    cache = True
    # 私有成员变量
    __api_key = 'xxx'

    def __init__(self, start, end):
        self.start = start
        self.end = end

    def getData(self):
    	try:
    		print(self.start)
    	except Exception as e:
    		raise
    	else:
    		pass
    	finally:
    		pass

    # 通过 classmethod 来声明静态方法，通过 cls 来取代 self
    @classmethod
    def get_lang_sql(cls, lang, date):
    	# statement

if __name__ == "__main__":
	person = Person('2019-10-10', '2019-10-20')
	person.getData()

```

### 访问限制

限制访问的目的在于不让类外部方法随意更改类的内部属性，保护内部状态

类比私有属性的概念，关键字为 `__`，比如 `self.__name`，这样实例对象就不能访问到 `__name` 这个属性，这个属性仅在类的内部使用

可以通过内部定义的 `get || set` 方法，将私有变量返回或者修改

写法比较

- `_name` 这种写法，在类外部是可以访问的，但是它按照 python 习惯，表示“可以访问，但是不要随意改变”

- `__name__` 表示特殊变量，在类外部是可以访问的

### class && instance

python 中的类通过 `class` 关键字声明，类的完整声明 `class Person(object):` 表示 person 这个类继承至 object，**注意**，所有的类本质上都继承至 object

通过 `__init__(self, params)` 来约定创建实例时，强制需要传入的参数，作用是将属性绑定到 `self` 上，`__self__` 就是实例本身，不用传入，且默认为第一个参数，可以类比 es6 的 `constructor()` 方法

通过 `self` 是给类的生成实例绑定属性，在类里面直接声明变量就是直接给类绑定属性，如果绑定了同名的属性，python3 会优先选择实例属性，所以一般不要声明同名属性

数据封装：因为实例在声明时就已经有了声明的数据，所以可以直接在类的内部去访问这些数据，而没必要去再在外部通过函数去访问（这意味着你需要维护实例初始化的数据，来随时作为参数传入函数）

**注意**

1. class 的名字第一个字母约定为大写
2. 类中定义方法的第一个参数必须是 `self`，可以类比 javascript 中的 `this` 关键字，指向实例本身
3. 与 javascript 不同之处之一在于：python 中创建一个实例不需要使用 `new` 关键字





## 面向对象和面向过程

面向过程的程序设计是把计算机程序视为**一系列的命令集合**，维护的是其执行顺序

面向对象的程序设计是把计算机程序视为**一组对象的集合**，维护的是消息在对象之间的传递

面向对象的抽象程序要比函数高，因为一个 class 既包含数据，又包含操作数据的方法

### class && instance

python 中的类通过 `class` 关键字声明，类的完整声明 `class Person(object):` 表示 person 这个类继承至 object，**注意**，所有的类本质上都继承至 object

通过 `__init__(self, params)` 来约定创建实例时，强制需要传入的参数，作用是将属性绑定到 `self` 上，`__self__` 就是实例本身，不用传入，且默认为第一个参数，可以类比 es6 的 `constructor()` 方法

通过 `self` 是给类的生成实例绑定属性，在类里面直接声明变量就是直接给类绑定属性，如果绑定了同名的属性，python3 会优先选择实例属性，所以一般不要声明同名属性

数据封装：因为实例在声明时就已经有了声明的数据，所以可以直接在类的内部去访问这些数据，而没必要去再在外部通过函数去访问（这意味着你需要维护实例初始化的数据，来随时作为参数传入函数）

**注意**

1. class 的名字第一个字母约定为大写
2. 类中定义方法的第一个参数必须是 `self`，可以类比 javascript 中的 `this` 关键字，指向实例本身
3. 与 javascript 不同之处之一在于：python 中创建一个实例不需要使用 `new` 关键字

### 访问限制

限制访问的目的在于不让类外部方法随意更改类的内部属性，保护内部状态

类比私有属性的概念，关键字为 `__`，比如 `self.__name`，这样实例对象就不能访问到 `__name` 这个属性，这个属性仅在类的内部使用

可以通过内部定义的 `get || set` 方法，将私有变量返回或者修改

写法比较

- `_name` 这种写法，在类外部是可以访问的，但是它按照 python 习惯，表示“可以访问，但是不要随意改变”

- `__name__` 表示特殊变量，在类外部是可以访问的

### 继承和多态

在面向对象中，一个类可以直接从另一个类中继承，形成子类与父类（或者说超类）的关系，子类会继承父类的所有属性和方法

子类可以重写父类方法，python 会优先执行子类方法

**在 python 中创建一个类，实际上就是创建了一个数据结构**，可以通过 `isinstance(instance, class)` 来判断

多态：因为类实际上定义了一种数据类型，所以我们可以在函数中将 instance 作为参数传入，从而可以直接调用父类的方法，而不必关心子类如何定义

“开闭原则”：

- 对扩展开放：允许新增子类
- 对修改封闭：不需要修改依赖父类实现的方法，子类即可调用

作为动态语言 python 的特别之处，**鸭子类型**：

- 在静态语言中，规定传参为 class，则必须为 class 或者其子类，否则报错
- 对于动态语言，只需要你传入的对象内也定义了某个方法，则可以执行完整的方法。即“看起来像鸭子，走起路来像鸭子，则它就是鸭子”

### @property

`@property` 可以理解为类的“装饰器”，它用于将一个**方法变成属性**调用，这样做的目的是避免通过 `__init__()` 方法定义的属性直接暴露出去，从而被任意修改，保证对参数进行必要的检查

`@property` 通过对变量进行赋值操作，完成对方法的传参操作

### 多重继承

在设计类的继承关系时，一般都是主线单一继承，但是如果需要混入额外的类的功能时，则需要用到多重继承，关键字是 `MixIn`

MixIn 的目的就是给一个类增加多个功能，这样可以避免设计出多层次的复杂继承关系，有效减少代码的复杂性和冗余

一般在以 `classnameMixIn` 的形式来定义 MixIn 类

### 定制类

python3 中通过定义形如 `__xxx__` 的方法来表示一组在 class 中有特殊用途的函数，用来帮我们定制类

实际表现就是，python3 定义了一批函数名，然后用户为其添加具体方法，最终在实例以某种形式就可以调用其函数方法，目的是为了让实例调用方法更加简单

如果没有定义这些特殊方法，python3 就会按照之前定义的执行

1. `__str__()` 在用户在调用 `print(Instance)` 时执行此

2. `__repr__()` 在直接打印 Instance 时调用，区别于 `__str__()` 它是为调试服务

3. `__iter__()` 方法返回一个迭代对象，使 Instance 能够作为迭代对象被 `for...in` 循环，同时还需要定义一个 `__next__()` 方法，使每次迭代时都调用此方法来返回下一个值，直到遇到 `StopInteration` 错误时退出循环

4. `__getattr__()` 方法用于实例调用属性或者方法时，如果原先没声明而直接使用就会调用该方法，利用 `__getattr__()` 结合返回函数可以生成**链式方法**

5. `__call__()` 用来直接调用实例，就像调用函数一样，本质上函数和类是同类，可以通过 `callable()` 方法来判断函数还是实例，因为如果一个对象能够被调用，那么它就是一个 **Callable 对象**

## 函数式编程

一个命名函数可以理解为：函数名为一个指向函数方法的变量

函数式编程就是指高度抽象的编程范式

### 高阶函数

一个函数（A）可以接受另一个函数（B）作为传参，则该函数（A）为高阶函数，有点像 JavaScript 中的回调函数

类似 JavaScript，python 内建的 `map()`, `reduce()`, `filter()` 就是典型的高阶函数，不过需要注意，其返回值是迭代器，所以一般通过 `list(Interator)` 将其转换为 list

高阶函数不仅可以接受一个函数作为参数，同时可以将函数作为返回值返回，所以高阶函数可以理解为**接受函数作为传参或者返回值的一类函数**

匿名函数关键字为 `lambda`

匿名函数有个限制，就是只能有一个表达式，不要写 `return`，返回值就是该表达式的结果

### 装饰器

举个例子：让一双 yeezy 具有防水功能，一个思路是添加各种科技，这可能会使 yeezy 变得不再轻便和耐看，更聪明的办法是套上一层鞋套。此时，yeezy 还是 yeezy，这层鞋套就相当于装饰器，在不改变 yeezy 的情况下，为其添加了防水功能

装饰器可以理解为函数增强的实现，它在不改变原函数的情况下，为其增加功能，不同于 java 纯面向对象的编程，python 装饰器是基于返回函数实现的，本质上，python 装饰器的返回值也是一个函数对象

> “在面向对象（OOP）的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要继承和组合来实现，但是 python3 除了支持 OOP 的装饰器外，还可以直接从语法上支持（即函数编程）装饰模式”

decorator 的关键字为 `@xxx`，`@` 是 python3 的语法糖，实际作用就是将函数的引用重新赋值

`wrapper(**args, **kw)` 是装饰器函数的标准写法，目的是为了 `wrapper()` 函数能够接受任何参数的调用

为了防止依赖函数签名的代码执行出现错误，通常通过 `@functools.wraps(func)` 来将原始属性写入新的函数中

`functools.partial()` 偏函数，起作用就是更改一个函数的原始默认值，同时返回一个新的函数
