---
id: concept
title: TypeScript Concept
sidebar_label: concept
slug: concept
---

🌼 We encourage the use of `--strictNullChecks` when possible!

## DataTypes

在 `JavaScript` 内，已经提供了一些原始类型：`boolean`, `bigint`, `null`, `number`, `string`, `symbol`, `object` 和 `undefined`

在此基础上，`TypeScript` 扩展了这个列表：

- `any` allow anything
- `unkonwn`
  - like you can't predict the user input
  - 用来通知编译器和未来的读者，这个变量可以是任意类型
  - 如果你使用了一个该类型的变量，你可以通过类型判断来进行处理
- `never` it's not possible that this type could happen
- `void` a function which returns undefined or has no return value

同时，TypeScript 提供了

1. `interface` 和 `type` 两种语法来创建自定义的 type
2. `union` 和 `generics(范型)` 来创建复杂的数据结构
3. `as` 通过断言来告诉编译器 `trust me, I know what I’m doing.`

接下来，我会对一些概念进行选择性地介绍，也许在工作中你已经掌握了它的使用方法，但是你并不清楚它的定义

### Tuple

`Tuple` 允许你声明一个具有特定顺序和数量的类型数组，这意味着你必须按照特定顺序和类型来进行取值和赋值操作

```typescript
let t: [string, number] = ['hello', 1]
// error: Type 'number' is not assignable to type 'string'.(2322)
t = [1, 'world']
```

### Union

For example like below:

```typescript
// define a complex datatype
function testType(value: string | string[]) {
  if (typeof value === 'string') {
    // statement
  } else if (Array.isArray(value)) {
    // statement
  }
}
```

### Generics

For example, we define a generics like below:

```typescript
interface GenericTest<Value> {
  get: () => Value
  set: (type: Value) => void
}

const gen: Generic<string> = {}
```

## Interface

> In JavaScript, some design patterns make it difficult for types to be inferred automatically.

To cover this case, TypeScript supports an extension of the JavaScript language, which offers places for you to tell TypeScript what the types should be.

就像在 Go 内 `interface` 的语义一样，`interface` 提供了**类似多态**的类型验证

Typescript 内的一个核心法则就是：类型检查专注于值具有的类型，类似 `duck typing` 的概念，“如果它走路像鸭子，叫的像鸭子，那么它就是鸭子”

`interface` 作为 TypeScript 新设计的类型，它可以用来描述 JavaScript 内丰富且灵活的类型，为此，它提供了一些很棒的特性：

1. **readonly**
   - 一些属性只有在创建的时候才能够被修改，这时候可以通过 `readonly` 来实现，同时 `TypeScript` 提供 `ReadonlyArray<T>` 类型来处理不可变数组
   - 🌼：声明**不可变属性**时，使用 `readonly` ，当声明一个**不可变变量**时，使用 `const`
2. **过多属性检查**
   - 传递的属性内含有 `interface` 内未定义的属性则会触发 TypeScript 内的过多属性检查，即对传递属性的数量、类型（不包括顺序）进行检查
   - 首选的解决方案：TypeScript 提供了一个好的解决方案 `[propname: string]:any` 来允许任意键值对
   - 同时，通过断言也可以来绕过这种类型检查，同时还有一种比较 hack 方法，将值赋值给一个新的变量来进行传递也可以对该类型检查进行规避
   - 此外，`[index: number]: string` 可以用来表示可索引类型，你应该熟悉 `index` 签名模式，它在开发过程中确实能够带来很多便利
3. 一个 `interface` 可以通过 `extends` 关键字来延伸**多个** `interface`，比如 `interface A extends B,C {}`

## Functions

> TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.

TypeScript 提供了两种方式来支持 `Function` 类型检查

1. 为每个参数添加类型，同时返回一个类型

```typescript
const add = (x: number, y: number): number {
  return x + y
}
```

2. 编写一个函数类型，此时必须通过 `=>` 来指定 `return` 类型

```typescript
const add: (x: number, y: number) => number = (x: number, y: number) {
  return x + y
}
```

### 形参

在 TypeScript 中，会默认检查每一个形参。这点很明显不同于 JavaScript，在 JavaScript 内，你可以传递任意属性的形参，对于函数内未定义的形参，会被赋值为 `undefined`

在 TypeScript 内，我们可以使用 `?` 关键字 、默认值以及 Rest Parameters（可以看作是无限数量的可选参数） 来进行更加灵活的配置，但是有一些点需要注意：

- 一般将 `?` 表示的可选参数放在参数列表的最后
- 默认值参数可以放在形参列表的任意位置，传参时通过 `undefined` 进行占位
- 在 JavaScript 内，可以通过 `arguments` 来获取传参，TypeScript 同样提供这样的能力，即通过 `(...restOfName: string[])` 这种模式，可以收集那些剩余参数到一个变量内

### 关于 this

> Arrow functions capture the `this` where the function is created rather than where it is invoked

在 TypeScript 内，可以开启 `--noImplictThis` 来通知编译器去检查 `this` 在定义时可能出现的问题

如果没有显示地定义 `this` 类型，会默认其类型为 `any`，因此你可以通过显示地定义 `this` 的类型来避免一些错误

```typescript
interface Demo {
  name: string
  setName(this: Demo): () => void
}
```

### overloads

一个有趣的特性，由于 JavaScript 本质上是一个相当动态的语言，因此一个函数通常可以接受不同类型的参数并且输出不同类型的结果

这个时候，我们如何为函数添加类型验证呢？来看一个官网的例子：

```typescript
// these two are overloads
function pickCard(x: { suit: string; card: number }[]): number
function pickCard(x: number): { suit: string; card: number }
// this not the overload
function pickCard(x: any): any {
  // Check to see if we're working with an object/array
  // if so, they gave us the deck and we'll pick the card
  if (typeof x == 'object') {
    let pickedCard = Math.floor(Math.random() * x.length)
    return pickedCard
  }
  // Otherwise just let them pick the card
  else if (typeof x == 'number') {
    let pickedSuit = Math.floor(x / 13)
    return { suit: suits[pickedSuit], card: x % 13 }
  }
}
```

编译器会根据顺序依次进行匹配，因此，通常将复杂的 overloads 放在前面

## Union

个人认为，`union` 是 TypeScript 内一个非常棒的特性，它提供了极大的便利性和兼容性，在学习官方文档的时候，它的一个特性让我对它有了更多的想象，它就是 `Discriminating Unions`

- 这里插一句，TypeScript 同样提供 `&` 关键字（**An intersection type combines multiple types into one**）来对多个类型进行合并操作

```typescript
interface TestA {
  name: 'a'
  age: number
}

interface TestB {
  name: 'b'
  surname: string
}

interface TestC {
  name: 'c'
  height: number
}

type Person = TestA | TestB | TestC

function testPerson(data: Person) {
  // Property 'age' does not exist on type 'Person'.
  // Property 'age' does not exist on type 'TestB'.(2339)
  console.log(data.age)

  // 我们可以利用**文本类型**来进行判断
  switch (data.name) {
    case 'a': {
      console.log(data.age)
      break
    }
    case 'b': {
      console.log(data.surname)
      break
    }
    case 'c': {
      console.log(data.height)
      break
    }
  }
}
```

## Classes

> A class declaration creates two things: a type representing instances of the class and a constructor function!

如果你厌烦了在 JavaScript 内通过函数和原型的方式来创建组件，那么通过类来创建是一个不错的尝试！

我们先从一个[简单的例子](https://github.com/Y-lonelY/study-typescript/blob/master/classes/define.ts)开始

在这个例子中，我们需要注意：

- 前置成员变量，表示其有成员访问权限
- 在 TypeScript 内，在调用 constructor 内的其他属性之前，必须**强制执行** `super()` 方法

Class 在被声明时会产生两个动作：

1. 创建一个代表类实例的类型，因此可以支持 `interface extends classes` 的写法
2. 创建一个构造函数

### 成员属性

和其他强类型语言一项，TypeScript 内的类也具有成员属性的概念，它提供 `public`、`private`、 `proteced` 以及 `readonly` ，默认为 `public`

这里比较特殊的是 `private`，TypeScript 既支持 ECMAScript 的语法（`#`）也有自己的语法（`private`）

- 相较之下，`#` 的写法内置在 JavaScript 的 runtime，因此它能够更好地保证私有字段的隔离
- `private` 的特点在于，即使两个类一模一样，但是只要包含 `private` 字段，则它们在类型判定上是不相等的，参考 [Y-lonelY/private](https://github.com/Y-lonelY/study-typescript/blob/master/classes/private.ts) 进行理解

关于 `protected` 总结了一些点，具有可以参考 [understanding-protected)](https://www.typescriptlang.org/docs/handbook/classes.html#understanding-protected) 来进行理解

- 父类内定义的 `protected` 属性，可以在其子类中进行访问，但是其实例（子类和父类的实例）不能访问
- 如果对父类的构造函数添加 `protected` 标志符，则不能将其进行实例化

## Common Utility

- `Partial<Type>` && `Required<Type>`
- `ReadOnly<Type>`
- `Pick<Type>` && `Omit<Type>`

这里我将以上 Utility Types 放在一起，是因为它们有相似的行为，即传入一个**类型定义**，返回一个**新的类型定义**，新的定义类型会基于原类型的属性进行更改

![common utility](/img/langs/typescript/commonUtility.png)

1. `Partial<Type>`，英译为**部分的**，用来将 `Type` 内所有的属性转换为可选类型，并返回一个新的类型，更通俗的解释就是：返回给定 `Type` 的所有子集
2. `Required<Type>` 行为与 `Partial<Type>` 恰恰相反，它会将 `Type` 内所有属性转换为必须类型，同时返回一个新的类型，即“我全都要”
3. `Readonly<Type>` 行为与 `Partial<Type>` 行为类似，它会将所有 `Type` 内的属性转换为**只读的**，并返回一个新的类型
4. `Pick<Type, keys>` 通过传递一个键的集合，从指定类型中取出指定的属性，返回一个新的类型定义，这里需要注意的是，**通过 `union` 来指定需要选择的属性**
5. `Omit<Type, keys>` 行为与 `Pick<Type, keys>` 相反，可以类比 `lodash.omit` 进行理解

这里展示 `Pick<Type, keys>` 的简单的示例，`Omit<Type, keys>` 可以类推

```typescript
// Pick
interface Person {
  name: string
  age: number
  isMale?: boolean
}

let a: Pick<Person, 'name' | 'age'> = {
  name: 'lucky',
  age: 27,
  isMale: true, // error: Object literal may only specify known properties, and 'isMale' does not exist in type 'Pick<Person, "name" | "age">'.(2322)
}
```

## Union Related

- `Exclude<Type, Union>` 相当于对两个集合求**差集**
- `Extract<Type, union>` 相当于对两个集合求**交集**

这里将包含 `union` 参数的 utility 归位一类，它们的行为类似对集合进行处理，在处理 `union` 类型时能够提供便利

![union](/img/langs/typescript/union.png)

参考下面这个例子进行理解：

```typescript
// Exclude<unionA, unionB>
type A = 'a' | 'b' | 'c'
type B = 'a' | 'f'

// type C = "b" | "c"
type C = Exclude<A, B>

// error: Type '"a"' is not assignable to type '"b" | "c"'.(2322)
let v1: C = 'a'

// Extract<unionA, unionB>
// type E = "a"
type E = Extract<A, B>

// Type '"b"' is not assignable to type '"a"'.(2322)
let v2: E = 'b'
```

## Function Related

- `Parameters<Type>`
- `ReturnType<Type>`

这里将函数类型的操作归为一类,主要针对函数的传参/返回值进行处理,返回相应的数据类型

![function](/img/langs/typescript/function.png)

1. `Parameters<Type>` 获取函数所有的传参, 并返回一个元组(tuple)
2. `ReturnType<Type>` 获取函数的返回值类型, 返回

参考下面的例子来进行理解:

```typescript
declare function f1(p: number, q: string): { a: number; b: string }

// 这里注意使用 typeof 来获取其类型
// 生成一个元组类型: [p: number, q: string]
type ParamsType = Parameters<typeof f1>

// success
const p1: ParamsType = [1, 'a']

// Type 'number' is not assignable to type 'string'.(2322)
const p2: ParamsType = [1, 2]

// ReturnType: 捕获返回值类型
type ReturnParams = ReturnType<typeof f1>

// success
const r1: ReturnParams = {
  a: 1,
  b: 'hello',
}

// The expected type comes from property 'b' which is declared here on type '{ a: number; b: string; }'
const r2: ReturnParams = {
  a: 1,
  b: 2,
}
```

## Interesting Utility

还有一些 Uitlity 拥有一些“有趣”的行为,这里将它们归为一类:

- `Record<Keys, Type>`
- `NonNullable<Type>`: 就是保证类型内不存在 `null` 和 `undefined`

`Record<Keys, Type>` 用于将每个 Key 内对应到指定 Type, 参考下面的例子来进行理解:

```typescript
interface Person {
  name: string
}

type Names = 'Kitty' | 'Nik'

const nav: Record<Names, Person> = {
  Kitty: { name: 'kitty' },
  Nik: { name: 'nik' },
}
```
