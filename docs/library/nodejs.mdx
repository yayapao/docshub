---
id: nodejs
title: Node.js Packages
sidebar_label: Node.js
slug: nodejs
---

import {
  HighlightWithCode,
} from '@site/src/components/Highlights'



## NEL

> [NEL](https://w3c.github.io/network-error-logging/) defines a mechanism that enables developers to declare a network error reporting policy for a web application

页面错误最严重的一种情况就是完全获取不到特定的资源，这可能是网络错误、加载资源发生错误，DNS 解析错误等原因造成的，并且这种错误难以复现，因此我们需要一个机制来处理此类情况，即当一个网络错误发生时，客户端能够上报 <b>在何时何处发生了什么事件，以及该类事件为何发生</b>

服务端无法完全处理此类错误，因为客户端可能还未与服务端建立连接就已经发生错误了，此时服务端根本无法察觉到

NEL(network-error-logging) 就是用来处理这类问题的一个机制，当客户端请求错误发生时，客户端 agent 会将该错误的类型、时间戳等信息进行解析并放入队列，然后通过读取队列将错误日志上报到指定位置。同时，它也支持上报正常的请求，用来统计不同客户群体内的错误率



## Typeorm

具体使用方法参考：

- [Typeorm 中文文档](https://typeorm.bootcss.com/)
- [nestjs Database](https://docs.nestjs.com/techniques/database)

这里我们主要记录在使用过程中碰到的问题：

### Q&A

[Cannot use import statement outside a module](https://stackoverflow.com/questions/59435293/typeorm-entity-in-nestjs-cannot-use-import-statement-outside-a-module)

- 场景：当使用 `typeorm.conf.ts` 的方式来引入配置时，想使用 `/**/*.entity.{ts,js}` 的方式来通配所有实体

- 原因：当使用 nestjs 的 monorepo 模式时，实际执行内容是 webpack 编译后的内容，在 .js 文件内引入 .ts 类型文件会报错

- 解决：
  1. 依次引入各个 entity 类后进行配置
  2. 参考 https://docs.nestjs.com/techniques/database#auto-load-entities 配置 `autoLoadEntities: true`

innerJoinAndSelect 使用问题

- `getMany()` 的返回值是 typeorm 对原生返回值处理后的结果，可能会过滤掉实力内不存在的值，并且对值的类型做转换，因此复杂的查询建议用 `getRawMany()`
- 在下面这种情况下，`getRawMany()` 返回的值也不一致，在数据库内是 `2021-09-04` ，但是查询出来是 `"2021-09-04T16:00:00.013Z"` ，是一个 ISOString 类型，解决方案是在 select 时通过 `'DATE_FORMAT(w.dt, "%Y-%m-%d") as dt'` 对其进行格式化操作

```typescript
crt = this.weightRegistry
  .createQueryBuilder('w')
  .innerJoinAndSelect('user', 'u', 'u.id = w.userId')
  // Date 类型使用 getRawMany 查询出来会是 ISOString，因此这里做一层转换，与横坐标对应
  .select([
    'w.value as value',
    'DATE_FORMAT(w.dt, "%Y-%m-%d") as dt',
    'u.name as name',
  ])
  .where('w.dt BETWEEN :st AND :et', { st, et })
  .andWhere('w.userId = :userId', { userId: +userId })
  .orderBy('w.dt', 'ASC')

// getMany() 只返回当前实体的转换后的结果
const data = await crt.getRawMany()
```

## Puppeteer

> Puppeteer is a Node library which provides a high-level API to control Chrome or Chromium over the DevTools Protocol.

简单来说，puppeteer 就是一个在 Node.js runtime 内的浏览器组件库，提供浏览器内核和系统的底层支持



## multer

> Multer 是一个 node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件

通过 `npm install --save @koa/multer multer` 来安装 [multer](https://github.com/koajs/multer)

[原文档，用来参考配置](https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md)

```js
import Router from 'koa-router'
import Compose from 'koa-compose'
import multer from '@koa/multer'
import utils from 'utility'

const uploadRouter = new Router()
// 创建文件存储规则
const storage = multer.diskStorage({
  // 文件存放路径，从文件根目录开始寻找
  destination: (req, file, cb) => {
    cb(null, 'upload')
  },
  // 重命名文件
  filename: (req, file, cb) => {
    // 格式化文件后缀
    const fileArray = file.originalname.split('.')
    const prefix = fileArray[0]
    const suffix = fileArray[1]
    // 添加时间戳，避免文件名重复
    cb(null, `${Date.now()}-${utils.md5(prefix)}.${suffix}`)
  },
})
// 创建文件上传限制
const limits = {
  //非文件字段的数量
  fields: 10,
  //文件大小 单位 b，3M
  fileSize: 10 * 1024 * 1024,
  //文件数量
  files: 1,
}

let upload = multer({ storage: storage, limits: limits })

// upload.single('file') 表示接受一个以 ‘file’ 命名的文件，且这个文件的信息保存在 ctx.request.file 字段内
// 文件上传错误，可以直接通过 try catch 进行捕获
uploadRouter.post('/upload', upload.single('file'), async (ctx) => {
  try {
    // 获取上传文件
    const file = ctx.request.file
    const results = {
      success: true,
      name: file.originalname,
      status: 'done',
      url: `http://192.168.1.103:7777/pics/${file.filename}`,
    }
    ctx.body = results
  } catch (e) {
    ctx.app.emit('error', e, ctx)
  }
})

const router = new Router()
router.use('/service', uploadRouter.routes(), uploadRouter.allowedMethods())

const router_routes = router.routes()
const router_allow_methods = router.allowedMethods()
const uploadCompose = Compose([router_routes, router_allow_methods])

export default uploadCompose
```

