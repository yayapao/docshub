---
id: handbook
title: React Handbook
sidebar_label: Handbook
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'
import { HighlightWithText } from '/src/components/Highlights'

<DocsHeader
  title="React Handbook"
  description="基于 React 官方文档进行解读和深入研究。"
  github="https://reactjs.org/docs/getting-started.html"
  tags={['React', 'Document']}
  links={[
    {
      label: 'useEffect vs useLayoutEffect',
      link: 'https://kentcdodds.com/blog/useeffect-vs-uselayouteffect',
    },
    {
      label: 'Before You memo()',
      link: 'https://overreacted.io/before-you-memo/'
    }
  ]}
/>{' '}

## 关于 re-render

在 React 内，发生 re-render 往往是由于一下原因：

- 组件 state 变化
- 父组件 re-render 导致子组件 re-render
- Context 变化
- Hooks 变化


## useMemo

:::note

`useMemo` caches a calculation result between re-renders untils its dependencies change.

:::

`memoization` 被用来在 re-renders 判断是否使用缓存，这意味着它不会解决第一次渲染带来的消耗，而会在组件更新时提供帮助。通常用来解决：

- 用 `useMemo` 处理消耗大量资源的重新计算（Skipping expensive recalculation）
- 用 `memo` 和 `useMemo` 处理组件的重新渲染（Skipping re-rendering of components）

```tsx
// 通过 `memo` 来包裹 List 组件，当 props 不发生改变时，List 不会被重新渲染
// 但是如果每次 props 都是一个新的数组（值相同，但是引用地址改变），则其仍会重新渲染
import { memo } from 'react';

const List = memo(function List({ items }) {
  // ...
});
```

此时需要结合 `useMemo` 来优化上游 props.

```tsx
export default function TodoList({ todos, tab, theme }) {
  // Tell React to cache your calculation between re-renders...
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab] // ...so as long as these dependencies don't change...
  );
  return (
    <div className={theme}>
      {/* ...List will receive the same props and can skip re-rendering */}
      <List items={visibleTodos} />
    </div>
  );
}
```

### 为什么不建议在任何地方使用 `useMemo`?

1. 代码可读性变差；
2. 有些组件即使用了 `useMemo` 也没啥影响，需要从底层去发现并解决问题，比如 `useMemo` 依赖值每次都更新，那么此时 `useMemo` 并无用处；

为了避免过度使用 memoization 我们应该遵循以下法则：

- 使用 JSX 作为子组件传递，当自身组件的 state 改变时，React 可以判断是否需要 re-render 子组件；
- 尽量不要提升 state，更多地使用 local state
- 保持更加纯粹的渲染逻辑
- 在状态更新时，避免不必要的 Effects
- 清除不必要的 Effetcs 依赖


## useEffect vs useLayoutEffet

<HighlightWithText text="One Word" />{' '}

`useEffect` 与 `useLayoutEffect` 的区别在于执行时机，99% 的场景都是使用 `useEffect`，因为其被设计有更好的执行性能。

**两者的执行时机**

- 用户交互导致组件内的 `props` 或者 `state` 变化
- React 执行完毕所有 DOM mutations
- `useLayoutEffect` 被触发，**同步执行**回调函数
- 浏览器重新绘制，可视化内容展示给到用户
- `useEffect` 被触发，**异步执行**回调函数

**更好的性能**

`useLayoutEffect` 与类组件的生命周期钩子: `componentDidMount` 和 `componentDidUpdate` 执行时机一样，会在 React 执行完毕所有 DOM 突变（mutations）后，浏览器重新绘制 DOM 变化内容前同步执行。因此会阻塞浏览器的渲染。

`useEffect` 会在浏览器重新绘制时异步执行其回调函数，此时不会阻塞浏览器渲染。

**useLayoutEffect 被用来？**

`useLayoutEffect` 被用来在浏览器渲染之前读取（perform measurements）或者改变 DOM 元素。通常被用来解决元素闪烁问题（在 React v18 版本， `useEffect` 已经表现无差别）。
