---
id: webapp
title: ''
sidebar_label: webapp
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'
import { HighlightWithText } from '/src/components/Highlights'

<DocsHeader
  title="Goars WebAPP Guide"
  description="Rules and resolutions for developing Go webapp."
  github="https://github.com/YaYaPao/goars"
  tags={['web']}
  links={[
    {
      label: 'How to cross-compile Go programs for Windows, Linux and MacOS.',
      link: 'https://freshman.tech/snippets/go/cross-compile-go-programs/',
    },
    {
      label: 'GORM 指南',
      link: 'https://gorm.io/zh_CN/docs/index.html',
    },
    {
      label: 'Stemming vs Lemmatization',
      link: 'https://towardsdatascience.com/stemming-vs-lemmatization-2daddabcb221',
    },
  ]}
/>{' '}

**在本章节将基于 goars 项目，介绍如何开始使用 Go 来开发 web-API 服务，并且使其拥有良好的开发规范和应用性能。**

- 基于 yaml 定义项目配置
- 基于 zap 作为项目日志管理工具
- 使用 Gin 作为 webapp 框架
- 使用 Gorm 作为连接数据库的客户端
- 基于 Redis 使用请求缓存
- 基于 JWT 作为用户 token 验证

## Preworks

### 设置环境变量

类似 Node.js，我们需要在项目内通过环境变量来定义不同场景下应用的行为：

```bash
# 开发环境
APP_ENV=development go run main.go

# 生产环境
APP_ENV=production ./main.go
```

在代码内获取当前环境变量：

```go
// 如果没有找到会返回空字符串
env := os.Getenv("APP_ENV")
```

### Compile and build

:::tip CROSS-COMPILE(交叉编译)

How do you build Go binaries that target operating systems and architectures other than your own? This is called cross-compiling.

:::

通过 `go env` 查看编译的环境变量，我们可以观察到本地的系统架构和目标（Host）的目标架构。Go 支持通过更改 `GOHOSTARCH` 和 `GOHOSTOS` 来编译指定环境的二进制包。

```bash
$ go env

# output
GOARCH="amd64" # 64-bit architecture
GOHOSTARCH="amd64"
GOHOSTOS="darwin"
GOOS="darwin"
```

#### MacOS

编译 MacOS 下二进制应用，如果本地使用 MacOS 开发，则直接 `go build` 即可。

```bash
# 64-bits
GOOS=darwin GOARCH=amd64 go build app.go

# 32-bits
GOOS=darwin GOARCH=386 go build app.go
```

#### Linux

编辑 Lunix 下二进制应用。

```bash
# 64-bit
GOOS=linux GOARCH=amd64 go build app.go

# 32-bit
GOOS=linux GOARCH=386 go build app.go
```

#### Windows

编译 `.exe` 应用：

```bash
# 64-bits
GOOS=windows GOARCH=amd64 go build app.go

# 32-bits
GOOS=windows GOARCH=386 go build app.go
```

## 项目组织结构

目录基于 tree（`brew install tree`） 生成。

```
.
├── conf # System config
├── docs # related documents
│   └── processor # logic flow processor
├── http_operation # http related：failed、successed、req/res structs
├── middleware # Router middlewares
├── models # Mapping orm and related methods(control data directly)
├── pkg # Self-defined packages
│   ├── cacheStore # Cache store for request
│   ├── core # Core methods(like Init())
│   ├── settings # Read from .yaml settings
│   ├── utils # Toolkits
│   └── zaplog # Logger based on zap
├── router # Register routes and return the router
│   ├── api # Mapping routes handler
│   └── routes # Module's routes
└── service # module's core handlers between model and api/routes


```

在 `main.go` 内，我们会在 `init()` 内调用各个模块的初始化方法，包括 settings, logger, database, cache。

之后会将初始化的路由对象实例化，启动服务。

## Start

Highly Recommended using **Goland RUN Configurations** to start APP.

> CAUTION: add `APP_ENV=development`

### Develop an API Interface

以下定义开发一个接口的主要流程：

1. Defined ORM Model struct in DIR `models/`;
2. In `models/[module]`, make common methods, like: `Save`, `Query`, `Exist` etc;
3. Defined Request/Response structs in DIR `http_operation/[module]`;
4. Defined API handlers in DIR `service/[module]`;
5. Defined GIN handle response in DIR `router/api/[module]`;
6. Defined the mapping of GIN response handler and GIN routes, in DIR `router/routes/[module]`;
7. Defined the mapping of router and GIN routes in `router/router.go`.

## Features Design

### Sentence Module

Sentence 模块用来帮助我快速积累英语词汇。在阅读计算机相关的文章、github 等时，将重点句子进行记录，由 Sentence Processor 进行一系列的处理后，对重点词汇进行储存。并且支持从不同维度进行查询。

![sentence-module](/img/langs/go/sentence-module.svg)

这里展示 sentence Model 在插入、查询时的处理过程。

:::note packages

- tokenizer - https://github.com/jdkato/prose
- stemming - https://github.com/kljensen/snowball
- lemmatization - https://github.com/aaaton/golem/
- stopWords - https://en.wikipedia.org/wiki/Most_common_words_in_English

:::

1. 插入以 sentence 为主体，分别进行 sentence 插入、分词处理。

- 我们将对 sentence 的处理放在 goroutine 内，它是一个异步过程。当接收用户存储 sentence 请求后，会判断其存在性，这里使用 `LIKE` 语句，如果不存在，则将其插入 _Sentence Table_ 并返回插入结果。与此同时，会另起一个线程对 sentence 进行处理。

- 对 sentence 处理包括 tokenizer（分词）-> Filter（去除标点和单字母）-> case-insensitive（大小写去敏）-> Filter（通用单词过滤）-> lemmatization（词形还原）-> Deduplication（去重）。

- 在经历上述处理后，我们会得到 word slice，在插入 _Word Table_ 之前，判断存在性，这里使用 `IN` 语句，如果不存在则进行插入，并返回每个 wordID。同时手动维护 sentenceID 和 wordID 的对应关系。

2. 查询支持通过 sentence 查询其关联的 sentence，或者通过 sentence 查询其关联的 word。

- 对于第一种情况，需要对 sentence 进行同步 tokenizer 流程处理，根据返回 word slice 进行匹配
- 对于第二种情况，通过 sentenceID 找寻其关联 word 进行返回

#### Why not stemming?

**在 Sentence Module 内，为什么我们选择用 lemmatization（词形还原）而不是 stemming（词干提取）呢？**

:::note

在 Sentence Module 的使用场景中，我们需要一个完成的单词而不是词干，并且将我们可以忽略执行效率带来的影响（将其放入 goroutine 内执行），因此选择更为合适的 lemmatization 技术。

:::

Stemming 和 lemmatization 都是将给定单词还原成基础单词的技术，stemming 通过匹配一系列规则来删除前缀和后缀，而 lemmatization 则基于对语言的理解对单词进行派生（需要加载语料库）。因此两者之前会存在差异：

- 对于一门新语言，steming 更具优势，因为 lemmatization 需要建立语言结构的相关模型
- 两者的实现原理决定 stemming 比 lemmatization 具备更高效率
- **stemming 并不能保证最后输出是一个真实存在的单词，但是 lemmatization 可以保证**

![stemming-vs-lemmatization](https://img.joyjoy.cc/docs/plang/go/stemming-vs-lemmatization.png)

## Coding Skills

### 聚合查询结果

假定这样一个查询场景：根据 N 个 Person 查询其对应的银行卡信息。现在存在两种处理方式：

1. 轮询 Person 列表，每个 Person 向数据库发起一次查询银行卡信息的请求；
2. 通过 `IN` 获取一批 Person 的银行卡信息后，再在应用层进行分类；

我们选择第二种方式来解决，因为数据库本身是很脆弱的，这里我们需要聚合查询结构。

```go

type Card struct {
  ID     uint
  Number uint
}

type Person struct {
  ID   uint
  Name string
}

type QueryResponse struct {
  Person
  Cards []Card
}


func FindPersonBindingCards(data []string) ([]QueryResponse, error) {
  // 根据姓名查询 Person 列表，即 []Person
	people, _ := models.QueryPeopleFromName(data)
	var personID []uint
  // mappings 用来表示 personID 和 QueryResponse 的对应关系
	mappings := make(map[uint]*QueryResponse)
  // 声明 res，作为最终返回结果，遍历 mappings 将 value 写入 res
	var res []QueryResponse

	for _, p := range people {
		personID = append(personID, p.ID)
		mappings[p.ID] = &QueryResponse{
			ID:        p.ID,
			Name:      p.Name,
			Cards:     []Card{},
		}
	}
  // 根据 personID 查询与其关联的所有 Card 信息，返回结果是包含 PersonID 和 Card 信息的切片
	cards, _ := models.QueryCardByPersonIDSlice(personID)

  // 遍历 cards 根据 card.PersonID 向 mappings.Cards 内进行填充
	for _, card := range cards {
		if _, ok := mappings[card.PersonID]; ok {
			mappings[card.PersonID].Cards = append(mappings[card.PersonID].Cards, Card{
				ID:       card.ID,
				Number:   card.Number,
			})
		}
	}

  // 遍历 mappings 生成最终 result 进行返回
	for _, value := range mappings {
		res = append(res, *value)
	}
	return res, nil
}

```

在实现过程中需要注意：

- 声明 map 对象时需要将其实例化，比如 `var mappings map[uint]string` 并直接为其赋值会产生错误，需要 `mappings := make(map[uint]string)` 或者 `mappings := map[uint]string{}` 将其进行实例化
- 在给 `mappings[card.PersonID].Cards` 进行赋值过程中，遇到过 [can't assign to xxx 错误](https://stackoverflow.com/questions/32751537/why-do-i-get-a-cannot-assign-error-when-setting-value-to-a-struct-as-a-value-i)，通过取址/取值操作符进行解决。原因在于 map 对象左侧操作必须是 **addressable**，而 `mappings[card.PersonID]` 并不能保证。
