---
id: feature
title: ''
sidebar_label: Feature
slug: feature
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="Browser Feature"
  description="浏览器特性及其使用"
  tags={['Browser']}
  links={[
    {
      label: 'Complete guide to file download in browsers',
      link: 'https://cybercafe.dev/complete-guide-to-file-download-in-browsers/',
    },
  ]}
/>{' '}

## 下载文件

在浏览器使用过程中，会发现其对于不同文件有不同的处理方式：它既可以预览文件内容，比如查看图片或者 PDF 文件，也可以直接下载 .zip 包。

通常而言，浏览器会根据文件内容自动进行判断，如果不能直接打开，则会将其下载。但是在某些场景下，我们需要主动去下载 image/PDF 文件。

我们在浏览器上能够实现两种下载文件的方式，这里我们将重点讨论第二种方式。

1. 右键“另存为”；
2. 点击按钮直接下载，比如在 unsplash 上下载图片；

## 跨域

出于浏览器的同源策略限制，协议，主机名，端口任一不同则形成跨域

解决跨域的办法：

- 通过 Nginx 反向代理
- 结合 src 属性，通过 jsonp 来处理跨域
- iframe 通过 postMessage 和 addEventListener('message')
- 通过 websocket 进行通信

jsonp 缺点：

- 只能使用 get 请求
- 安全问题
- 不能返回各种 http 状态码

```js
// postMessage
// 发起方
var traget = document.getElementById('#test').postMessage('hello');
// 接收方通过事件监听
window.addEventListener('message', function (e) {});

// jsonp
// 向服务器test.com发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字
<script src="http://test.com/service?callback=dosomething"></script>

// 处理服务器返回回调函数
<script type="text/javascript">
    function dosomething(res){
        // 处理获得的数据
        console.log(res.data)
    }
</script>

// 服务器回传数据
dosomething({data: data});


// websocket
// 建立一个 websocket 实例对象
var socket = new WebSocket("ws://www.test.com/service/data.do");
// 只能够发送少量 string 类型的数据
socket.send('hello');
// 客户端接受服务端信息，通过监听 message
socket.on('message', function(event) {
    var data = event.data;
})
// 关闭 socket 协议
socket.close();
```

### iframe 跨域问题

这里记录一下项目内碰到的跨域问题以及解决办法

iframe 相关跨域问题

- [CSP: frame-ancestors](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors)

iframe srcdoc 属性尝试和拉取指定 url 的 document，在这个过程中：

- 通过 http 请求获取指定 url 的文档模型
- 通过 http 请求获取仍然存在跨域问题，通过替换成其他 url，发现可以获取到 html 元素，但是其中的引用资源，如果本身是相对路径，则会在本域加载不到
- 在请求过程中服务器做了一次转发，因此会出现 302 状态码，直接被 onerror 捕获错误

```js
// 获取指定url的document
getUrl () {
  var request = this.makeHttpObject()
  request.open("GET", targetUrl, true)
  request.send(null)
  request.addEventListener("loadend", function (e) {
    console.log(e.target.responseText)
    self.$refs.iframe.srcdoc = e.target.responseText
  })
  request.addEventListener("error", function (e) {
    const headers = request.getResponseHeader("location")
    console.log({ e, headers })
  })
},
```

## 在浏览器输入 URL 的执行过程

URL 结构：

- scheme: 通信协议，比如 https 等
- host: 主机地址
- port: 端口号，用来标志进程
- path: 虚拟文件路径，说明资源位于服务器什么地方
- query: 查询参数
- hash: 信息片段字符串，锚点部分

明确一个概念，一个 URL 就是一个特定资源，该资源可能需要引用多个其他资源作为支撑

服务端交互获取渲染对象

- DNS 解析
- HTTP 请求（ TCP 三次握手，四次分手，请求/响应报文结构，Cookie，代理服务器）

通过浏览器渲染指定的资源文件

- 渲染关键路径
- 重绘和回流
