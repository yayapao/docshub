---
id: libs
title: ''
sidebar_label: Libraries
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="Node.js Libraries"
  description="Libraries based on Node.js eco."
  tags={['Node.js']}
  links={[
    {
      label: 'How to write stories',
      link: 'https://storybook.js.org/docs/react/writing-stories/introduction',
    },
    {
      label: 'Storybook Control Annotations',
      link: 'https://storybook.js.org/docs/react/essentials/controls#annotation',
    },
    {
      label: 'Storybook argTypes available properties',
      link: 'https://storybook.js.org/docs/react/api/argtypes#available-properties',
    },
  ]}
/>{' '}

## StoryBook

StoryBook 是一个用于前端构建 UI 组件的工作空间，它适用于任意流行前端框架，这里我们基于 React 进行介绍。

### 使用 pnpm + vite

:::caution CORE

核心在于使 `npx storybook@latest init -f` 执行成功

:::

1. 在目录下创建基于 vite 的 React + TS 项目

```bash

$ pnpm create vite story --template react-ts

```

2. 进入 story 目录，配置 storybook

```bash

$ cd story && mkdir .storybook && touch .storybook/main.ts

```

3. 初始化 storybook 安装程序，会自动修改启动脚本、导入 example 组件、引入 storybook 相关依赖

```bash

$ npx storybook@latest init -f

```

**注意安装执行顺序，初始化完毕之后，查看 package.json.scripts 启动脚本**

## 编写一个 story

这里我们基于 React + TypeScript 项目展开，在开始前你需要准备好一个 React 组件。

story 以 `[component name].stories.[js | ts | tsx | jsx | mdx]` 的形式进行命名， stories 基于 `Component Story Format(CSF)` 的标准进行编写，**即 export default meta 用于描述组件，named export 用于描述 story。**

- stories 使用 UpperCamelCase 命名
- **通常 story properties 可以定义在全局、组件或者 stories**， 其优先级为：named export > default export > global defination
- ⚠️，全局 story properties 定义在 `.storybook/.preview.js` 内，其他定义在 `stories` 内

举例说明（TS + React 项目）：

```tsx
import { Button } from 'Where/Component/Is/Defined'
import type { Meta, StoryObj } from '@storybook/react'

const meta = {
  title: 'ui/Button', // storybook 中展示的标题，通过 / 进行分组，代表 [组件库]/[组件]
  component: Button,
  tags: ['autodocs'], // 用于描述/搜索 story
  // argTypes 设置组件 props 的类型、默认值以及交互控制
  argTypes: {
    backgroundColor: { control: 'color' },
    size: {
      control: { type: 'select', options: ['small', 'medium', 'large'] },
    },
  },
  decorators: [
    (Story) => (
      <div style={{ margin: '3em' }}>
        <Story />
      </div>
    ),
  ],
} satisfies Meta<typeof Button>
// export default meta
export default meta

// named export
export const Primary: StoryObj<typeof Button> = {
  args: {
    primary: true,
    size: 'small',
  },
}
```

##### decorators

`decorators` 用于设置 story 的装饰器，比如组件容器（全局）样式、全局状态等，是一个数组，可以设置多个装饰器

- 对于框架内置的 Provider （比如 MUI 的 ThemeProvider） 可以在 `.storybook/.preview.js` 内设置 decorators
- 可以在 decorators 内执行 side effect，比如加载数据等，而不用在 args 内进行设置

##### play function

`play` 可以定义组件渲染完成之后，执行的代码块，通常设置在 named export story，可以设置组件的交互行为或者测试场景。在 `play` 方法内，需要用 storybook 内提供的一套方法来获取、操作、交互页面元素。

- 定义的操作流程可以在 `Interactions` 内检查

## Redux

[redux](https://redux.js.org/introduction/getting-started) 不局限于使用，它可以在任何框架内使用，它的出现主要是为了解决**多交互，多数据源下的代码结构和组件通信**

从组件角度看，state 不外乎有两个作用：`get` 和 `set`，即**获取状态**和**通过改变状态来引起交互**

- 某个组件的状态，需要共享
- 某个状态需要在任何地方能够拿到，即一个全局状态
- 一个组件可以改变全局状态
- 一个组件需要改变另一个组件的状态

之前用 react 的 props 来实现通信，父组件向子组件通信方便，但是兄弟组件和子组件向父组件通信的话，前者需要提升状态至其公共父组件，后者需要声明一些额外的函数，不是很优雅

Redux 的设计思路：

1. Web 应用就是一个状态机，视图和状态一一对应
2. 所有的状态都保存在一个对象内

### Store

Store 可以理解成一个容器，用来保存数据，整个应用只能有一个 Store，它通过 `createStore()` 方法进行创建，它可以接受的参数：

- Reducer
- defaultState
- applyMiddleware()

Store 的职责：

1. 维持应用的 state
2. 提供 `Store.getState()` 来获取 state
3. 提供 `Store.dispatch(action)` 来通知 reducer 根据 action 更新 state，是 View 发出 Action 的唯一方式
4. 通过 `subscribe(listener)` 来注册监听器和通过其返回函数销毁监听器，表示一旦 state 发生变化，立即调用监听函数，在 React 项目中，只要把 `render()` 或者 `setState()` 方法放入监听函数中，就可以实现 View 的自动渲染

### State

::: warning
"建议你尽可能地把 state 范式化，不存在嵌套。把所有数据放到一个对象里，每个数据以 ID 为主键，不同实体或列表间通过 ID 相互引用数据"
:::

State 可以看作是对 Store 对象内某个时间点的数据的一次快照，一个应用只有一个 Store，只要 state 相同则可以判定其视图相同

### Action

**Action 仅仅用来描述有事情发生这一事实，并不会更新 state**

一般来说，用户接触不到 Store，自然也无法改变它，用户接触到的是视图，所以改变 Store 内 state 是用户通过视图发起的，而这个过程的媒介就是 Action

Action 就是 View 发起的通知，来通知 state 需要变化

Action 是一个对象，`type` 属性为必需属性，用来表示 Action 名字

只有两个对象完全相同时，则两个 Action 才相等，否则为独立的 Action，因此随着传递信息的不同，会产生很多个 Action，这时需要封装一个函数来作为 Action Creater(即 Action 生成器，用来简化代码结构)

### Reducer

Store 收到一个新的 Action 后，通过 Reducer 进行相应的计算，返回一个新的 state

Reducer 可以简单表示为 `Reducer(currentState, action) -> newState`，它是一个纯函数(即输入相同，则输出一定相同)，接受 Action 和 当前 State 作为参数，返回一个新的 State

在实际应用中，Reducer 不用手动调用，在生成 Store 实例时，将其作为参数传入，之后每当 `store.dispatch(action)` 传递来一个新的 action 时，就会自动调用 Reducer

**reducer 一定要保持纯净，可以理解为：只要传入参数相同，返回计算得到的下一个 state 就一定相同，没有特殊情况、没有副作用、没有 API 请求、没有变量修改，单纯执行计算**

因此，在 reducer 一定不可以：

1. 修改传入参数 state，可以利用 `Object.assign({}, state)` 来进行拷贝，也可以使用展开运算符进行拷贝
2. 执行有副作用的操作，比如 API 请求和路由跳转
3. 调用非纯函数，比如 `Date.now()`，`Math.random()` 等
4. 一定要返回 state，如果遇到未知的 action，可以直接返回旧的 state

### Redux Work Flow

了解以上几点概念之后，可以对 redux 的工作流程做一个梳理：

1. 用户在 React Components 通过视图层发出 Action，即 `dispatch(action)`
2. Store 接受到 Action 之后调用 Reducer，向其传递 state 和 action 参数，并且接收 Reducer 返回的新 State
3. State 一旦发生变化，就会调用 `subscribe(listener)` 监听函数，listener 通过 `getState()` 获得当前的 State，再利用 React 的 setState() 来重新渲染

### Middleware

中间件就是一个函数，对 `store.dispatch(action)` 进行改造，在发出 Action 和执行 Reducer 之间，添加其他功能

在 Redux 中，在创建 Store 时，通过传递 `applyMiddleware(middleware1,...)` 参数来引入中间件

**注意：中间件的引入也需要注意顺序**

### Redux in React

这里看一个简单的示例：

`store.js`，用来生成 store 实例，添加中间件和集成 reducer

```javascript
import { createStore, combineReducers, applyMiddleware } from 'redux'
import thunk from 'redux-thunk'
import * as dashBoard from '@/store/dashBoard/reducer'

let store = createStore(
  combineReducers({ ...dashBoard }),
  applyMiddleware(thunk)
)

export default store
```

`actionType.js`，用来规定一些 types

```javascript
const dailyCharts: string = 'DAILYCHARTS'
export { dailyCharts }
```

`dashBoard/reducer.js`，DashBoard 模块的 reducer，用来根据 action，返回新的 state

```javascript
import * as Type from './actionType'

// default
let defaultState = {
  dailyList: [],
  sumMap: {},
}

export const dashBoardData = (state = defaultState, action = {}) => {
  switch (action.type) {
    case Type.dailyCharts:
      return {
        ...state,
        ...{
          dailyList: action.dailyList,
          sumMap: action.sumMap,
        },
      }
    default:
      return state
  }
}
```

`dashBoard/action.js`，action genertor，action 生成器，用来返回 action

```javascript
import * as Type from '@/store/dashBoard/actionType'

const changeChart = (dailyList, sumMap) => {
  return {
    type: Type.dailyCharts,
    dailyList,
    sumMap,
  }
}

export { changeChart }
```

`dailyView.jsx`，state 在组件内的使用

```javascript
import { connect } from 'react-redux'
import { changeChart } from '../../store/dashBoard/action'
// statements
export default connect(
  (state) => ({
    dashBoardData: state.dashBoardData,
  }),
  {
    changeChart,
  }
)(DailyView)
```

### Store 传递

要使每个组件都能够获取到 Store

1. 第一种办法，将 store 作为 props 属性传递到每一个被 `connect()` 包装的组件内
2. 更加推荐的做法，是通过 `<Provider store={store}>` 组件来包裹根组件

方法 2 的原理是将 Store 挂载到 React 组件的 context 属性上，所以可以通过 `const { store } = this.context` 来获取 store 对象

### Connect

`Connect()` 用来连接 React 组件和 Redux Store，连接操作不会更改原来组件，返回值为一个新的与 Redux Store 连接的组件类

作用是将视图组件转换为容器组件，作为容器组件，其需要定义输入和输出：

1. 输入逻辑：外部数据（即 state 对象）如何转换为视图组件的参数
2. 输出逻辑：用户动作如何转变为 Action，从视图组件传出

### mapStateToProps

mapStateToProps 参数负责输入逻辑，本质是一个函数，输入为 state，输出为 state 对象到当前组件 props 对象的映射关系，返回值是一个对象，每一个键值对都表示一组映射

mapStateToProps 第一个形参一定是 state，但是其还可以接受 `ownProps`，其代表容器组件的 props 对象，使用 ownprops 作为参数后，如果容器组件的参数发生变化时，也会引发 视图组件的重新渲染

mapStateToProps 不是必需的，如果不传，则表示 Store 的更新不会引起当前视图组件的更新

### mapDispatchToProps

mapDispatchToProps 负责输出逻辑，用来建立视图组件参数到 `store.dispatch()` 方法的映射，它可以是一个函数，也可以是一个对象

作为函数，接受 `dispatch` 和 `ownProps` 作为形参，返回值是一个对象，每个键值对都是一个映射，定义视图组件的参数怎样发出 Action

更多的用法是作为对象，其键名（比如 xxx）对应视图组件的同名属性名（对应 `this.props.xxx`），其键值为一个 Action Creator，是一个函数

## React Router

::: tip
React 生态的路由组件
:::

执行 `npm install react-router-dom --save` 或者 `yarn add react-router-dom` 来引入

⚠️ [react-router future](https://reacttraining.com/blog/reach-react-router-future/) 将会发布新的路由组件，主要是因为 React Hooks 的发布从根本上改变了生态，从而引发了 react-router 的重构，可以关注一下！

简单介绍下 [react-router](https://reactrouter.com/web/example/basic) 的基础知识和一些可利用的组件，接着会介绍针对项目内的使用和组件封装方法

### Basic

React-router 包含三种类型组件，**路由器匹配组件**通常映射一个业务模块，当 url 改变时则会去匹配该模块并展示，所有的路由器匹配组件都必须被包裹在**路由器组件**内：

1. 路由器组件， like `<BrowserRouter>` and `<HashRouter>`
2. 路由器匹配组件，like `<Route>` and `<Switch>`
3. 导航组件，like `<Link>`, `<NavLink>`, and `<Redirect>`

---

此外，React-router 还提供了一些很棒的特性：

- [Prompt](https://reactrouter.com/web/example/preventing-transitions) 用来阻止用户直接退出当前路径，通常用来确定用户表单提交
- [no-match](https://reactrouter.com/web/example/no-match) 用来捕获匹配到的路由，并对其进行处理
- 一个页面内，多个地方匹配路由是一种很常见的场景，比如侧边栏、面包屑和主体内容，在 React-router 内，不过是实现多个 `<Switch><Route></Route></Switch>` 的事情，参考 [Sidebar](https://reactrouter.com/web/example/sidebar)
- React-router 提供 [animated-transitions](https://reactrouter.com/web/example/animated-transitions) 来处理页面切换的过渡效果，注意需要引入 `react-transition-group`
- [Modal Gallery](https://reactrouter.com/web/example/modal-gallery) 是一个 hack 方法的实例，通过 state 同时支持在当前页面内跳转和替换当前页面两种展示模式

### Use In App

在 react 项目中，对 react-router 的封装

1. `RouteConfig.js` 用来引入相关的组件，实现对路由的配置，实现对 `<Route>` API 的相关属性配置
2. `Router.js` 用来实现路由递归逻辑，输入 config，输出 react-router 相关的组件
3. 在 `app.js` 内引入 `RouteConfig.js` 和 `Router.js`，并通过 `<BrowserRouter>` 或者其他 API 来封装启动路由

### Q&A

问题描述：使用 `BroswerRouter` 是，进入到某个模块，例如 `/module` 后，刷新页面，返回 404

原因：当刷新页面时，浏览器会向服务器请求 example.com/list，服务器实际会去找根目录下 list.html 这个文件，发现找不到，因为实际上我们的服务器并没有这样的 物理路径/文件 或没有配置处理这个路由，所有内容都是通过 React-Router 去渲染 React 组件，所以会产生 404 错误

解决：

通过修改 nginx 配置，访问任何 URI 都指向 index.html，浏览器上的 path，会自动被 React-router 处理，进行无刷新跳转

```nginx

server {
    server_name react.thinktxt.com;
    listen 80;

    root /Users/txBoy/WEB-Project/React-Demo/dist;
    index index.html;
    location / {
        try_files $uri /index.html;
    }
}
```

### 路由跳转

在 `react-router` 内实现路由跳转，可以通过 `<Link>`、`withRouter`、`useHistory`、`<Redirect>`、`<NavLink>` 来实现

::: tip
推荐使用 `useHistory` 获取 `history` 对象来控制路由跳转
:::

### Link

针对 `to` 属性，可以支持 string、object、function 三种形式

通过 `replace` 来控制 `target = blank or self`

```ts
// with params && query
<Link
  to={{
    pathname: '/courses',
    search: '?sort=name',
    hash: '#the-hash',
    state: { fromDashboard: true },
  }}
/>
```

### withRouter

给控件绑定事件，使其能够通过 javascript 来实现跳转，通过 `withRouter` 来实现，相当于将 `history` 对象赋值在 `props` 上

```js
import { withRouter } from 'react-router-dom';
class FlowHeader extends React.Component<FlowHeaderProps, FlowHeaderState> {
	// statement

    handleRouter = (index) => {
        const selectedItem = flowItems[index];
        if (selectedItem.label === this.state.currentItem) {
            return;
        } else {
            this.props.history.push('/');
        }
    }
}

export default withRouter(FlowHeader);

// use in redux
export default withRouter(connect(...)(MyComponent))
```

## Node-Sass 安装问题

clone 一个 react 项目后，在执行 `npm install` 之后，发现 node-sass 安装出现问题，原因是无法自动下载相应的文件

解决办法：

- 注意要先将之前安装的错误的 node-sass 进行删除
- 在错误日志内查看需要的版本，在[官网](https://github.com/sass/node-sass/releases)下载相应的版本
- 将下载文件放在 nodejs 的根目录下
- 进入项目根目录，设置 sass 路径，`set SASS_BINARY_PATH=[file path]`
- 继续执行 `sudo npm i node-sass -D -verbose` 即可

## React Hot Loader

::: tip
"React Hot Loader is a plugin that allows React components to be live reloaded without the loss of state"
:::

[React-hot-loader](https://github.com/gaearon/react-hot-loader) 是一个插件，允许 React 组件在不丢失状态的条件下进行实时重新加载操作

webpack-dev-server 也实现了热加载，但是是在代码改动后，经过重新打包，进而重新刷新整个页面

不同于 webpack-dev-server，react-hot-loader 不会刷新整个页面，它只替换修改的代码，进而做到了页面的局部刷新，其需要依赖 webpack 的 HotModuleReplacement 热加载插件

### Use In App

1. `npm install react-hot-loader --save` 引入 react-hot-loader
2. 配置 .babelrc 文件，启用相关插件，在 create react app 且 `npm run eject` 之后，可以直接在 package.json 内进行 babel 相关配置

```json
"babel": {
	"presets": [
	  "react-app"
	],
	"plugins": [
	  "react-hot-loader/babel"
	]
},
```

3. webpack 进行相关文件配置，用来保证 react-hot-loader 在引入 `react` 和 `react-dom` 之前加载

```javascript
// webpackDevServer.config.js
module.exports = function (proxy, allowedHost) {
  return {
    hot: true,
  }
}

// webpack.config.js
entry: ['react-hot-loader/patch']
```

4. 在项目文件内使用

```javascript
// App.js
import { hot } from 'react-hot-loader/root'
const App = () => <div>Hello World!</div>
export default hot(App)
```
