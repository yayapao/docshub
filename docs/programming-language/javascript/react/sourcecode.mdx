---
id: reactsecret
title: ''
sidebar_label: React Secret
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="React Secret"
  description="从思想到框架，再到源码，抽丝剥茧解决 React 的秘密"
  github="https://github.com/facebook/react"
  tags={['React']}
  links={[
    {
      label: 'React 技术揭秘',
      link: 'https://react.iamkasong.com/preparation/idea.html#react%E7%90%86%E5%BF%B5',
    },
    {
      label: 'React 官网',
      link: 'https://react.dev/',
    },
  ]}
/>{' '}

## React 解决的问题

在最开始，React 官方是这样描述 React 的：

:::note

React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。

:::

如何理解呢？我们知道应用的瓶颈无外乎** CPU 计算瓶颈和 IO 瓶颈。** 尤其是在浏览器运行时内，JS 线程和 GUI 渲染线程是互斥的，它们不能同时运行。众所周知，主流浏览器的刷新频率是 60HZ，即一帧的时间为 ≈16.6ms，在这个时间单元内，需要完成**JS 脚本执行 > 页面布局 > 样式渲染**。

当 JS 线程运行时间大于 16.6ms 时（一帧），就会出现卡顿现象，这就是 CPU 计算瓶颈。而 IO 瓶颈则是指网络请求、文件读写等操作，这些操作都是异步的，但是当它们执行完毕后，需要通知 JS 线程，这就需要 JS 线程不断地去轮询，这就是 IO 瓶颈。

为了解决上诉瓶颈，实现**快速响应**，React 内部实现了将同步更新转换为**异步可中断更新**的设计。这样，当 JS 线程执行时间过长时，就可以将控制权交还给 GUI 渲染线程，保证页面的流畅度，同时当执行完异步操作后，也可以通知 JS 线程，保证数据的一致性。

官网更新后，React 的描述变成了这样：

:::note

The library for web and native user interfaces

:::

它不再强调性能，而是强调了**跨平台**，这也是 React 未来的发展方向。

## React Fiber

React Fiber 是 React 16 中新的协调引擎（reconciler），对比之前的 Stack Reconciler，它是实现了**异步可中断更新**的关键。它的出现，使得 React 可以在不阻塞主线程的情况下，进行**增量渲染**，以达到更好的用户体验。

### 设计灵感

在我们深入了解 Fiber 架构之前，我们需要进行理论知识储备。

:::info 进程、线程、协程、纤程

- 进程（Processor）: 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位
- 线程（Thread）: 是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源
- 协程（Coroutine）: 是一种用户态的轻量级线程，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，切换回来时，恢复先前保存的寄存器上下文和栈，因此协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置
- 纤程（Fiber）: 有争议。

:::

_进程&线程_

关于以上知识，我们拓展一下，比如现在你有一个 API 服务跑在 80 端口上，实际上计算机就启动了一个进程，这个进程就是你的 API 服务，而这个进程中，可能有多个线程，比如你的 API 服务中有一个线程负责处理请求，一个线程负责写日志，一个线程负责读取数据库，这些线程都是在一个进程中，它们共享进程的资源，比如内存，文件句柄等。

-协程-

思考下 NodeJS 生态和 Go 生态，不难发现“天然”基于协程设计的 Goroutine，没有令人烦恼的 promise/async/await 这些异步方法的编写，同时也不会出现回调地狱，这就是协程的魅力。同时，协程更加轻量，非抢占式，不需要上下文切换（我理解是当程序执行时，线程切换时不需要切换上下文指针，因为协程本身能够保留上一次的调用状态），不需要内核介入，所以它的性能更高。

:::Algebraic Effects

代数效应是 React Fiber 实现的理论基础，它是一种计算机编程语言的特性，它可以将副作用从函数中分离出来，从而实现可中断的函数，可中断意味着可以复用中断之前的执行上下文，从而实现可中断的异步编程。

:::

代数效应和协程的概念是不是很相似，都是用户控制，而不是系统控制，都是可中断的，都可以复用上下文，但是代数效应是一种理论，而协程是一种实现，代数效应可以实现协程，但是协程并不一定是代数效应。

#### 定义

在 JS 生态内，Generator 函数就是一种协程，它可以通过 yield 关键字将函数的执行权交还给调用者，同时保留函数的上下文，这样就可以实现异步编程，但是 Generator 函数并不是一个完整的协程实现，它只是协程的一种语法糖，因为它需要手动调用 next 方法，而且它的执行权只能交还给调用者，不能交还给其他函数，所以从实现和编程语法上来说，它并不是一个完美的协程实现。

因为，React 提出 React Fiber 来进行更加完整的协程实现。**它是一套状态更新机制，支持不同任务优先级，能够中断和恢复，在恢复时可以复用之前的上下文，从而实现了可中断的异步编程。**

**已知 JavaScript 是单线程的，为什么还说 React Fiber？两种说法不是矛盾的吗？**

在 React 中，Fiber 是一种将可中断的任务切片处理的一种方式，这种方式可以被认为是一种协程，但是它并不是 JavaScript 中的协程，因为 JavaScript 是单线程的，它只是利用了浏览器的空闲时间来执行任务，这样就可以将一个大的任务拆分成很多小的任务，每次执行一个小任务，然后将控制权交还给浏览器，这样就可以实现**增量渲染**，从而提升用户体验。
