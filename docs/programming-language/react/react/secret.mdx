---
id: secret
title: ''
sidebar_label: React Secret
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<DocsHeader
  title="React Secret"
  description="从思想到框架，再到源码，抽丝剥茧了解 React 的秘密"
  github="https://github.com/facebook/react"
  tags={['React']}
  links={[
    {
      label: 'React 技术揭秘',
      link: 'https://react.iamkasong.com/preparation/idea.html#react%E7%90%86%E5%BF%B5',
    },
    {
      label: 'React 官网',
      link: 'https://react.dev/',
    },
  ]}
/>{' '}

React 无疑是 JavaScript 生态中浓墨重彩的一笔，它的出现，彻底改变了前端开发的方式，它的思想，影响了整个前端生态。那么，我希望通过更加深入阅读 React 源码，来探索 React 的秘密，从而更加深入地理解 React 的思想。

1. React 解决了什么问题？
2. React 做好了哪些工作，使它得以如此流行？

## React 解决的问题

在最开始，React 官方是这样描述 React 的：

:::note

React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。

:::

如何理解呢？我们知道应用的瓶颈无外乎** CPU 计算瓶颈和 IO 瓶颈。** 尤其是在浏览器运行时内，JS 线程和 GUI 渲染线程是互斥的，它们不能同时运行。众所周知，主流浏览器的刷新频率是 60HZ，即一帧的时间为 ≈16.6ms，在这个时间单元内，需要完成**JS 脚本执行 > 页面布局 > 样式渲染**。

当 JS 线程运行时间大于 16.6ms 时（一帧），就会出现卡顿现象，这就是 CPU 计算瓶颈。而 IO 瓶颈则是指网络请求、文件读写等操作，这些操作都是异步的，但是当它们执行完毕后，需要通知 JS 线程，这就需要 JS 线程不断地去轮询，这就是 IO 瓶颈。

为了解决上诉瓶颈，实现**快速响应**，React 内部实现了将同步更新转换为**异步可中断更新**的设计。这样，当 JS 线程执行时间过长时，就可以将控制权交还给 GUI 渲染线程，保证页面的流畅度，同时当执行完异步操作后，也可以通知 JS 线程，保证数据的一致性。

官网更新后，React 的描述变成了这样：

:::note

The library for web and native user interfaces

:::

它不再强调性能，而是强调了**跨平台**，这也是 React 未来的发展方向。

## React Fiber

React Fiber 是 React 16 中新的协调引擎（reconciler），对比之前的 Stack Reconciler，它是实现了**异步可中断更新**的关键。它的出现，使得 React 可以在不阻塞主线程的情况下，进行**增量渲染**，以达到更好的用户体验。

### 设计灵感

在我们深入了解 Fiber 架构之前，我们需要进行理论知识储备。

:::info 进程、线程、协程、纤程

- 进程（Processor）: 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位
- 线程（Thread）: 是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源
- 协程（Coroutine）: 是一种用户态的轻量级线程，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，切换回来时，恢复先前保存的寄存器上下文和栈，因此协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置
- 纤程（Fiber）: 有争议。

:::

_进程&线程_

关于以上知识，我们拓展一下，比如现在你有一个 API 服务跑在 80 端口上，实际上计算机就启动了一个进程，这个进程就是你的 API 服务，而这个进程中，可能有多个线程，比如你的 API 服务中有一个线程负责处理请求，一个线程负责写日志，一个线程负责读取数据库，这些线程都是在一个进程中，它们共享进程的资源，比如内存，文件句柄等。

_协程_

思考下 NodeJS 生态和 Go 生态，不难发现“天然”基于协程设计的 Goroutine，没有令人烦恼的 promise/async/await 这些异步方法的编写，同时也不会出现回调地狱，这就是协程的魅力。同时，协程更加轻量，非抢占式，不需要上下文切换（我理解是当程序执行时，线程切换时不需要切换上下文指针，因为协程本身能够保留上一次的调用状态），不需要内核介入，所以它的性能更高。

#### 代数效应

:::info Algebraic Effects

代数效应是 React Fiber 实现的理论基础，它是一种计算机编程语言的特性，它可以将副作用（effect）从函数中分离出来，从而实现可中断的函数，可中断意味着可以复用中断之前的执行上下文（context），从而实现可中断的异步编程。

:::

代数效应和协程的概念是不是很相似，都是用户控制，而不是系统控制，都是可中断的，都可以复用上下文，但是代数效应是一种理论，而协程是一种实现，代数效应可以实现协程，但是协程并不一定是代数效应。

代数效用是针对函数式编程的概念，因为它解决的是函数式编程中特有的问题。它解决了函数 what 和 how 的耦合问题。举个例子：

现在我们需要实现一个函数，它的功能是从数据库中读取数据，然后将数据写入到文件中，那么我们可以这样实现：

```js
// readAndWrite 通过代码可以清除看到它实现的功能，即 what is readAndWrite
function readAndWrite() {
  const conn = perform ConnectDB()
  const data = perform Read(conn)
  perform Write(data)
}
```

接下来我们实现 how 的部分：

```js
// 注意，这里 handle 只是为了表述方便，实际上并不是一个 js 实现
try {
  readAndWrite()
} handle (effect) {
  if (effect instanceof ConnectDB) {
    // ...
  } else if (effect instanceof Read) {
    // ...
  } else if (effect instanceof Write) {
    // ...
  }
}
```

#### React 和代数效应

**为什么 React 不使用 generator 实现代数效应？**

在 JS 生态内，Generator 函数就是一种协程，它可以通过 **yield 关键字**将函数的执行权交还给调用者，同时保留函数的上下文，这样就可以实现异步编程，但是 Generator 函数并不是一个完整的协程实现，它只是协程的一种语法糖，因为它需要**手动调用 next 方法**，而且**它的执行权只能交还给调用者，不能交还给其他函数**，所以从实现和编程语法上来说，它并不是一个完美的协程实现。

因为，React 提出 React Fiber 来进行更加完整的协程实现。**它是一套状态更新机制，支持不同任务优先级，能够中断和恢复，在恢复时可以复用之前的上下文，从而实现了可中断的异步编程。**

**已知 JavaScript 是单线程的，为什么还说 React Fiber？两种说法不是矛盾的吗？**

在 React 中，Fiber 是一种将可中断的任务切片处理的一种方式，这种方式可以被认为是一种协程，但是它并不是 JavaScript 中的协程，因为 JavaScript 是单线程的，它只是利用了浏览器的空闲时间来执行任务，这样就可以将一个大的任务拆分成很多小的任务，每次执行一个小任务，然后将控制权交还给浏览器，这样就可以实现**增量渲染**，从而提升用户体验。

### 核心工作原理-双缓存

:::caution 双缓存

在内存中构建，并完成替换的技术叫做双缓存

:::

想想如何没有双缓存会发生什么？用户产生交互后，浏览器先将新页面挂载，然后通过计算得出差异，再将差异更新到页面上，假设这个过程需要过量计算，或者在这个过程中用户产生了新的交互，那么就会出现明显的页面卡顿/闪烁的现象。

**而采用双缓存技术，我们可以将计算和渲染分离，在内容中构建出新的页面，之后直接替换旧的页面，这样就可以避免页面卡顿/闪烁的现象。**

![double-buffer.png](https://img.joyjoy.cc/react/double-buffer.png)

在 React 中，双缓存意味着最多需要维持两套 Fiber 树。一套是当前屏幕上显示内容的 Fiber 树，称为 current Fiber 树，另一套是准备渲染的 Fiber 树，称为 workInProgress Fiber 树。树与树之间，通过 `alternate` 属性进行连接。

React 应用的根节点为 **fiberRoot**，其 current 指针指向的树，就是 current Fiber Tree。一个 React 项目只有一个 fiberRoot。与之需要辨明得是 - **rootFiber**。通过调用 `ReactDOM.render` 方法创建的节点是 rootFiber，一个 React 项目内可以同时存在多个 rootFiber。

1. fiberRoot 通过改变 current 指针，能够将 current Fiber Tree 和 workInProgress Fiber Tree 进行切换，从而实现双缓存。这个过程发生在 `commit` 阶段；
2. workInProgress Fiber Tree 通过 `alternate` 属性，能够与 current Fiber Tree 进行连接。这个过程发生在 `render` 阶段；

## 本地调试

参考 [How to Contribute – React](https://legacy.reactjs.org/docs/how-to-contribute.html)，我们可以通过以下步骤进行本地调试：

1. `git clone git@github.com:facebook/react.git` 到本地；
2. 进入本地仓库后，执行 `yarn install` 安装依赖；
3. 执行 `yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE` 编译原文件；
4. 进入 `react, react-dom, scheduler` 对应目录，执行 `yarn link`
5. 进入项目内，执行 `yarn link react react-dom scheduler`，这样就可以将本地的 react, react-dom, scheduler 与项目内的 react, react-dom, scheduler 进行关联，从而实现本地调试；

```bash
# 注意，现在产物位于 build/oss-stable 目录下，与官网有一定差异，其他产物同理
cd build/oss-stable/scheduler
yarn link

# link 成功后，会打印如下信息：
# yarn link v1.13.0
# success Registered "scheduler".
# info You can now run `yarn link "scheduler"` in the projects where you want to use this package and it will be used instead.

```

### 准备 JDK 环境

在执行 build 过程中，需要依赖 java runtime，因此需要确保 JDK 已安装，并且版本满足要求。这里我记录如何解决 MacOS 下，JDK 版本不匹配的问题。

在 build 过程中，发现 JDK Runtime 版本不满足要求，通过 `java -version` 查看，发现版本过低导致，因此需要升级 JDK 版本。

```bash
brew info openjdk

brew install openjdk

# 下载完成之后，进入 /Library/Java/JavaVirtualMachines 查看当前版本文件，之后将最新下载的版本通过软链接的方式进行替换
# 在此之前可以考虑删除 /Library/Java/JavaVirtualMachines 目录下的其他旧版本文件
sudo ln -sfn /usr/local/opt/openjdk@20/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdk

# 之后进入 /Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home 查看版本，发现版本已经更新
# 编辑 ~/.bash_profile 文件
touch .bash_profile
open -e .bash_profile

# 在文件中添加如下内容
JAVA_HOME="/Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home"
export JAVA_HOME
CLASS_PATH="$JAVA_HOME/lib"
PATH=".$PATH:$JAVA_HOME/bin"

# 刷新 .bash_profile 文件，即可完成替换
source .bash_profile
```

## JSX && createElement

**为什么 React 使用 JSX 来组织代码，而不是传统的 CSS + HTML + JS?**

    “Web 的交互性越来越强，逻辑越来越决定页面中的内容”

参考 [createElement – React](https://react.dev/reference/react/createElement)，我们不难看出，**JSX 可以看作是 createElement 的语法糖，因为 JSX 在编译阶段会被转换为 createElement 函数调用。** 因此，我理解 JSX 是一种约定的语法规范，可以在编译阶段通过 `@babel/plugin-transform-react-jsx` 将其转换为 `React.createElement` 方法调用。

:::caution

JSX 并不是一定只能转换成 **createElement** 方法，你可以修改 @babel/plugin-transform-react-jsx 方法将其转换成其他函数，比如在 preact 内会将 JSX 转换为 **h** 方法

:::

<Tabs>
  <TabItem value="jsx" label="JSX" default>
    <code>
      {`
    export function App() {
      return <div className="app">Hello, React</div>
    }
    `}
    </code>
  </TabItem>
  <TabItem value="createElement" label="createElement">
    <code>
      {`
    export function App() {
      return React.createElement('div', { className: 'app' }, 'Hello, React')
    }
    `}
    </code>
  </TabItem>
</Tabs>

从源码 [React \* createElement 实现](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react/src/ReactElement.js#L348) 可以看出，**createElement 最终输出一个 ReactElement 对象，除了其他属性回传之外，会增加 `$$typeof: REACT_ELEMENT_TYPE` 来标记当前元素为 React 元素。**

```jsx title="/packages/react/src/ReactElement.js"
export function createElement(type, config, children) {
  let propName

  // Reserved names are extracted
  const props = {}

  let key = null
  let ref = null
  let self = null
  let source = null

  // ...分别从 config 内提取 ref 和 key 并赋值给当前变量...
  // ...遍历 config 将其key和value赋值给 props
  // ...处理 children，如果传多个，则将其写入数组内，最终赋值给 props.children
  // ...处理 defaultProps

  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props
  )
}
```

ReactElement 重点关注，返回值多了个 `$$typeof` 用来标记当前元素为 React 元素。

```js title="/packages/react/src/ReactElement.js"
function ReactElement(type, key, ref, self, source, owner, props) {
  const element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner,
  }

  return element
}
```

## 构建 Fiber Tree

:::caution

以下源码块，省略了 DEV 环境和 **lanes 优先级**处理的代码。

:::

FiberTree

### beginWork

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"

function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // 判断当前节点是否需要更新，如果 current 不为 null，则说明当前节点已经存在，需要进行更新，否则需要进行创建
  if (current !== null) {
    // updated 阶段
    const oldProps = current.memoizedProps
    const newProps = workInProgress.pendingProps

    // 判断 props 或者 context 是否发生变化，如果发生变化，则需要进行更新
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
    ) {
      didReceiveUpdate = true
    } else {
      // 检查是否有正在执行的 context 或者 update 改变任务，如果没有，则直接释放
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes
      )
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        didReceiveUpdate = false
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes
        )
      }
    }
  } else {
    didReceiveUpdate = false
    // 检查当前 workInProgress 是否有兄弟节点，即是否属于一个分叉子组件
    // 由此判断是否需要**在并行渲染线程**上渲染子组件，并代表一个新的渲染线程
    // pushTreeId 根据 workInProgress, numberOfForks（分叉数）, slotIndex（槽索引）计算新的
    // treeContextId、treeContextOverflow 以及 treeContextProvider，并将当前的数据压入栈中
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index
      const numberOfForks = getForksAtLevel(workInProgress)
      pushTreeId(workInProgress, numberOfForks, slotIndex)
    }
  }

  // 如果是 mount 阶段，会根据 workInProgress.tag 的不同类型，新建不同的 Fiber 节点
  switch (workInProgress.tag) {
    case IndeterminateComponent // ...省略
    case LazyComponent // ...省略
    case FunctionComponent: {
      const Component = workInProgress.type
      const unresolvedProps = workInProgress.pendingProps
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps)
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes
      )
    }
    case ClassComponent // ...省略
    case HostRoot // ...省略
    case HostHoistable // ...省略
    case HostSingleton // ...省略
    case HostComponent // ...省略
    case HostText // ...省略
    case SuspenseComponent // ...省略
    case HostPortal // ...省略
    case ForwardRef // ...省略
    case Fragment // ...省略
    case Mode // ...省略
    case Profiler // ...省略
    case ContextProvider // ...省略
    case ContextConsumer // ...省略
    case MemoComponent // ...省略
    case SimpleMemoComponent // ...省略
    case IncompleteClassComponent // ...省略
    case SuspenseListComponent // ...省略
    case ScopeComponent // ...省略
    case OffscreenComponent // ...省略
    case LegacyHiddenComponent // ...省略
    case CacheComponent // ...省略
    case TracingMarkerComponent // ...省略
  }

  // 如果没有匹配类型，会直接抛出错误
}
```

### updateFunctionComponent

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes
) {
  let context
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
    context = getMaskedContext(workInProgress, unmaskedContext)
  }

  let nextChildren
  let hasId
  prepareToReadContext(workInProgress, renderLanes)
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress)
  }

  nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  )
  hasId = checkDidRenderIdHook()
  if (enableSchedulingProfiler) {
    markComponentRenderStopped()
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes)
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
  }

  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress)
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork
  reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  return workInProgress.child
}
```

## Type Defination

### Fiber

Fiber 在 reconciler 内大量使用，它是 current, workInProgress 的基础，它是一个链表结构，每个节点都是一个 Fiber 对象，它的结构如下：

```ts

export type Fiber = {
  // Tag 用来标记当前 Fiber 的类型，比如 ClassComponent、HostRoot、HostComponent、HostText 等
  tag: WorkTag,

  // key 是当前 Fiber 的唯一标识，用于区分同一个父节点下的不同子节点
  key: null | string,

  // 其值来源于 element.type，用来标记当前 Fiber 对应的组件类型
  elementType: any,

  // type 用来标记当前组件是 class component 或者 function component
  type: any,

  // 当前 Fiber 的状态，比如是否更新、是否有副作用等
  stateNode: any,

  // 由于 Fiber type 混合了 Fiber 和 Instance，如果是 Fiber，则 return 实际上是指 parent
  return: Fiber | null,

  child: Fiber | null,
  sibling: Fiber | null,
  index: number,

  // 最后用于附加此节点的 ref
  ref:
    | null
    | (((handle: mixed) => void) & {_stringRef: ?string, ...})
    | RefObject,

  refCleanup: null | (() => void),

  // Input is the data coming into process this fiber. Arguments. Props.
  pendingProps: any, // This type will be more specific once we overload the tag.
  memoizedProps: any, // The props used to create the output.

  // 状态更新队列
  updateQueue: mixed,

  // 用于创建输出状态
  memoizedState: any,

  // 当前 Fiber 的依赖，比如 (contexts, events)
  dependencies: Dependencies | null,

  // 描述 Fiber 及其子节点的比特字段，比如 ConcurrentMode 用来标记当前子树是否是异步渲染的
  // 一般来说，在创建时会确定该字段，并且后在后续更新时不会改变。默认情况下，子树会沿用父节点的 mode
  mode: TypeOfMode,

  // Effect
  flags: Flags,
  subtreeFlags: Flags,
  deletions: Array<Fiber> | null,

  // Singly linked list fast path to the next fiber with side-effects.
  nextEffect: Fiber | null,

  // The first and last fiber with side-effect within this subtree. This allows
  // us to reuse a slice of the linked list when we reuse the work done within
  // this fiber.
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,

  lanes: Lanes,
  childLanes: Lanes,

  // This is a pooled version of a Fiber. Every fiber that gets updated will
  // eventually have a pair. There are cases when we can clean up pairs to save
  // memory if we need to.
  alternate: Fiber | null,

  // Time spent rendering this Fiber and its descendants for the current update.
  // This tells us how well the tree makes use of sCU for memoization.
  // It is reset to 0 each time we render and only updated when we don't bailout.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualDuration?: number,

  // If the Fiber is currently active in the "render" phase,
  // This marks the time at which the work began.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualStartTime?: number,

  // Duration of the most recent render time for this Fiber.
  // This value is not updated when we bailout for memoization purposes.
  // This field is only set when the enableProfilerTimer flag is enabled.
  selfBaseDuration?: number,

  // Sum of base times for all descendants of this Fiber.
  // This value bubbles up during the "complete" phase.
  // This field is only set when the enableProfilerTimer flag is enabled.
  treeBaseDuration?: number,
};


```
