---
id: fiber
title: 'fiber'
sidebar_label: fiber
---

fiber 是 React v16 之后提出，用于取代虚拟 Dom 说法的一种架构设计。**目的是为了解决虚拟 DOM 在遍历更新时，如果树足够复杂，导致线程阻塞的问题，fiber 将递归的无法中断的更新策略替换为异步的可中断更新。**

Fiber 包含以下含义：

    1. 在 React v16 之前，reconciler 采用递归的方式，数据保存在递归调用栈内，因此也叫 **stack reconciler**。而在 React v16 之后，基于 Fiber 实现，因此也叫 **Fiber reconciler**；
    2. 每个Fiber节点对应一个 React Element，保存了该组件的全部信息，包括：类型、DOM节点信息、本次更新组件状态、要执行的操作等；

## Fiber 基础概念

### FiberNode

FiberNode 构造函数接受 `tag, pendingProps, key, mode` 作为参数，其中 tag 用来标记当前 FiberNode 类型，参考 [ReactWorkTags](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactWorkTags.js)

**FiberNode 是一个链表结构，用 `return, child, sibling` 来表示关联关系**

```jsx title="packages/react-reconciler/src/ReactFiber.new.js"
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode
) {
  // Instance
  this.tag = tag
  this.key = key // key 是当前 Fiber 的唯一标识，用于区分同一个父节点下的不同子节点
  this.elementType = null // 其值来源于 element.type，用来标记当前 Fiber 对应的组件类型，大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
  this.type = null // 标记当前组件是 class component 或者 function component，对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
  this.stateNode = null // Fiber对应的真实DOM节点

  // Fiber，用来表示当前 FiberNode 的关联关系
  this.return = null // return指节点执行完completeWork后会返回的下一个节点，通常为父节点
  this.child = null
  this.sibling = null // 右边第一个兄弟节点
  this.index = 0

  this.ref = null

  // 保存本次更新造成的状态改变相关信息
  this.pendingProps = pendingProps
  this.memoizedProps = null
  this.updateQueue = null // 状态更新队列
  this.memoizedState = null
  this.dependencies = null

  this.mode = mode

  // Effects，render 相关
  this.flags = NoFlags
  this.subtreeFlags = NoFlags
  this.deletions = null

  // lanes 用来控制调度优先级
  this.lanes = NoLanes
  this.childLanes = NoLanes

  // 缓存相关
  this.alternate = null
}
```

### HostRootFiber

`HostRootFiber` 是使用 `createHostRootFiber` 创建的 Fiber 根节点，它包含整棵 Fiber 树信息。在源码内同 `rootFiber`，React 应用内可以同时存在多个 `rootFiber`。

### FiberRootNode

`FiberRootNode` 表示应用根节点，一个 React 应用内只有一个，在源码内也用 `FiberRoot` 表示。它保存着应用的状态和组件信息。

## render 阶段

## beginWork

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"

function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // 判断当前节点是否需要更新，如果 current 不为 null，则说明当前节点已经存在，需要进行更新，否则需要进行创建
  if (current !== null) {
    // updated 阶段
    const oldProps = current.memoizedProps
    const newProps = workInProgress.pendingProps

    // 判断 props 或者 context 是否发生变化，如果发生变化，则需要进行更新
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
    ) {
      didReceiveUpdate = true
    } else {
      // 检查是否有正在执行的 context 或者 update 改变任务，如果没有，则直接释放
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes
      )
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        didReceiveUpdate = false
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes
        )
      }
    }
  } else {
    didReceiveUpdate = false
    // 检查当前 workInProgress 是否有兄弟节点，即是否属于一个分叉子组件
    // 由此判断是否需要**在并行渲染线程**上渲染子组件，并代表一个新的渲染线程
    // pushTreeId 根据 workInProgress, numberOfForks（分叉数）, slotIndex（槽索引）计算新的
    // treeContextId、treeContextOverflow 以及 treeContextProvider，并将当前的数据压入栈中
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index
      const numberOfForks = getForksAtLevel(workInProgress)
      pushTreeId(workInProgress, numberOfForks, slotIndex)
    }
  }

  // 如果是 mount 阶段，会根据 workInProgress.tag 的不同类型，新建不同的 Fiber 节点
  switch (workInProgress.tag) {
    case IndeterminateComponent // ...省略
    case LazyComponent // ...省略
    case FunctionComponent: {
      const Component = workInProgress.type
      const unresolvedProps = workInProgress.pendingProps
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps)
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes
      )
    }
    case ClassComponent // ...省略
    case HostRoot // ...省略
    case HostHoistable // ...省略
    case HostSingleton // ...省略
    case HostComponent // ...省略
    case HostText // ...省略
    case SuspenseComponent // ...省略
    case HostPortal // ...省略
    case ForwardRef // ...省略
    case Fragment // ...省略
    case Mode // ...省略
    case Profiler // ...省略
    case ContextProvider // ...省略
    case ContextConsumer // ...省略
    case MemoComponent // ...省略
    case SimpleMemoComponent // ...省略
    case IncompleteClassComponent // ...省略
    case SuspenseListComponent // ...省略
    case ScopeComponent // ...省略
    case OffscreenComponent // ...省略
    case LegacyHiddenComponent // ...省略
    case CacheComponent // ...省略
    case TracingMarkerComponent // ...省略
  }

  // 如果没有匹配类型，会直接抛出错误
}

```

## updateFunctionComponent

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes
) {
  let context
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
    context = getMaskedContext(workInProgress, unmaskedContext)
  }

  let nextChildren
  let hasId
  prepareToReadContext(workInProgress, renderLanes)
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress)
  }

  nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  )
  hasId = checkDidRenderIdHook()
  if (enableSchedulingProfiler) {
    markComponentRenderStopped()
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes)
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
  }

  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress)
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork
  reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  return workInProgress.child
}
```
