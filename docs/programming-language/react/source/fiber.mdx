---
id: fiber
title: 'fiber'
sidebar_label: fiber
---

:::warning

以下源码块，省略了 DEV 环境和 **lanes 优先级**处理的代码。

:::

## beginWork

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"

function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // 判断当前节点是否需要更新，如果 current 不为 null，则说明当前节点已经存在，需要进行更新，否则需要进行创建
  if (current !== null) {
    // updated 阶段
    const oldProps = current.memoizedProps
    const newProps = workInProgress.pendingProps

    // 判断 props 或者 context 是否发生变化，如果发生变化，则需要进行更新
    if (
      oldProps !== newProps ||
      hasLegacyContextChanged() ||
    ) {
      didReceiveUpdate = true
    } else {
      // 检查是否有正在执行的 context 或者 update 改变任务，如果没有，则直接释放
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes
      )
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        didReceiveUpdate = false
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes
        )
      }
    }
  } else {
    didReceiveUpdate = false
    // 检查当前 workInProgress 是否有兄弟节点，即是否属于一个分叉子组件
    // 由此判断是否需要**在并行渲染线程**上渲染子组件，并代表一个新的渲染线程
    // pushTreeId 根据 workInProgress, numberOfForks（分叉数）, slotIndex（槽索引）计算新的
    // treeContextId、treeContextOverflow 以及 treeContextProvider，并将当前的数据压入栈中
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index
      const numberOfForks = getForksAtLevel(workInProgress)
      pushTreeId(workInProgress, numberOfForks, slotIndex)
    }
  }

  // 如果是 mount 阶段，会根据 workInProgress.tag 的不同类型，新建不同的 Fiber 节点
  switch (workInProgress.tag) {
    case IndeterminateComponent // ...省略
    case LazyComponent // ...省略
    case FunctionComponent: {
      const Component = workInProgress.type
      const unresolvedProps = workInProgress.pendingProps
      const resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps)
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes
      )
    }
    case ClassComponent // ...省略
    case HostRoot // ...省略
    case HostHoistable // ...省略
    case HostSingleton // ...省略
    case HostComponent // ...省略
    case HostText // ...省略
    case SuspenseComponent // ...省略
    case HostPortal // ...省略
    case ForwardRef // ...省略
    case Fragment // ...省略
    case Mode // ...省略
    case Profiler // ...省略
    case ContextProvider // ...省略
    case ContextConsumer // ...省略
    case MemoComponent // ...省略
    case SimpleMemoComponent // ...省略
    case IncompleteClassComponent // ...省略
    case SuspenseListComponent // ...省略
    case ScopeComponent // ...省略
    case OffscreenComponent // ...省略
    case LegacyHiddenComponent // ...省略
    case CacheComponent // ...省略
    case TracingMarkerComponent // ...省略
  }

  // 如果没有匹配类型，会直接抛出错误
}

```

## updateFunctionComponent

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes
) {
  let context
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
    context = getMaskedContext(workInProgress, unmaskedContext)
  }

  let nextChildren
  let hasId
  prepareToReadContext(workInProgress, renderLanes)
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress)
  }

  nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  )
  hasId = checkDidRenderIdHook()
  if (enableSchedulingProfiler) {
    markComponentRenderStopped()
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes)
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
  }

  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress)
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork
  reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  return workInProgress.child
}
```

## Type Defination

### Fiber

Fiber 在 reconciler 内大量使用，它是 current, workInProgress 的基础，它是一个链表结构，每个节点都是一个 Fiber 对象，它的结构如下：

```ts

export type Fiber = {
  // Tag 用来标记当前 Fiber 的类型，比如 ClassComponent、HostRoot、HostComponent、HostText 等
  tag: WorkTag,

  // key 是当前 Fiber 的唯一标识，用于区分同一个父节点下的不同子节点
  key: null | string,

  // 其值来源于 element.type，用来标记当前 Fiber 对应的组件类型
  elementType: any,

  // type 用来标记当前组件是 class component 或者 function component
  type: any,

  // 当前 Fiber 的状态，比如是否更新、是否有副作用等
  stateNode: any,

  // 由于 Fiber type 混合了 Fiber 和 Instance，如果是 Fiber，则 return 实际上是指 parent
  return: Fiber | null,

  child: Fiber | null,
  sibling: Fiber | null,
  index: number,

  // 最后用于附加此节点的 ref
  ref:
    | null
    | (((handle: mixed) => void) & {_stringRef: ?string, ...})
    | RefObject,

  refCleanup: null | (() => void),

  // Input is the data coming into process this fiber. Arguments. Props.
  pendingProps: any, // This type will be more specific once we overload the tag.
  memoizedProps: any, // The props used to create the output.

  // 状态更新队列
  updateQueue: mixed,

  // 用于创建输出状态
  memoizedState: any,

  // 当前 Fiber 的依赖，比如 (contexts, events)
  dependencies: Dependencies | null,

  // 描述 Fiber 及其子节点的比特字段，比如 ConcurrentMode 用来标记当前子树是否是异步渲染的
  // 一般来说，在创建时会确定该字段，并且后在后续更新时不会改变。默认情况下，子树会沿用父节点的 mode
  mode: TypeOfMode,

  // Effect
  flags: Flags,
  subtreeFlags: Flags,
  deletions: Array<Fiber> | null,

  // Singly linked list fast path to the next fiber with side-effects.
  nextEffect: Fiber | null,

  // The first and last fiber with side-effect within this subtree. This allows
  // us to reuse a slice of the linked list when we reuse the work done within
  // this fiber.
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,

  lanes: Lanes,
  childLanes: Lanes,

  // This is a pooled version of a Fiber. Every fiber that gets updated will
  // eventually have a pair. There are cases when we can clean up pairs to save
  // memory if we need to.
  alternate: Fiber | null,

  // Time spent rendering this Fiber and its descendants for the current update.
  // This tells us how well the tree makes use of sCU for memoization.
  // It is reset to 0 each time we render and only updated when we don't bailout.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualDuration?: number,

  // If the Fiber is currently active in the "render" phase,
  // This marks the time at which the work began.
  // This field is only set when the enableProfilerTimer flag is enabled.
  actualStartTime?: number,

  // Duration of the most recent render time for this Fiber.
  // This value is not updated when we bailout for memoization purposes.
  // This field is only set when the enableProfilerTimer flag is enabled.
  selfBaseDuration?: number,

  // Sum of base times for all descendants of this Fiber.
  // This value bubbles up during the "complete" phase.
  // This field is only set when the enableProfilerTimer flag is enabled.
  treeBaseDuration?: number,
};
```
