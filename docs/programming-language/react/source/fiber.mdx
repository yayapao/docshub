---
id: fiber
title: 'fiber'
sidebar_label: fiber
---

fiber 是 React v16 之后提出，用于取代虚拟 Dom 说法的一种架构设计。**目的是为了解决虚拟 DOM 在遍历更新时，如果树足够复杂，导致线程阻塞的问题，fiber 将递归的无法中断的更新策略替换为异步的可中断更新。**

Fiber 包含以下含义：

    1. 在 React v16 之前，reconciler 采用递归的方式，数据保存在递归调用栈内，因此也叫 **stack reconciler**。而在 React v16 之后，基于 Fiber 实现，因此也叫 **Fiber reconciler**；
    2. 每个Fiber节点对应一个 React Element，保存了该组件的全部信息，包括：类型、DOM节点信息、本次更新组件状态、要执行的操作等；

## Fiber 基础概念

### FiberNode

FiberNode 构造函数接受 `tag, pendingProps, key, mode` 作为参数，其中 tag 用来标记当前 FiberNode 类型，参考 [ReactWorkTags](https://github.com/facebook/react/blob/9e3b772b8cabbd8cadc7522ebe3dde3279e79d9e/packages/react-reconciler/src/ReactWorkTags.js)

**FiberNode 是一个链表结构，用 `return, child, sibling` 来表示关联关系**

```jsx title="packages/react-reconciler/src/ReactFiber.new.js"
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode
) {
  // Instance
  this.tag = tag
  this.key = key // key 是当前 Fiber 的唯一标识，用于区分同一个父节点下的不同子节点
  this.elementType = null // 其值来源于 element.type，用来标记当前 Fiber 对应的组件类型，大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
  this.type = null // 标记当前组件是 class component 或者 function component，对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
  this.stateNode = null // Fiber对应的真实DOM节点

  // Fiber，用来表示当前 FiberNode 的关联关系
  this.return = null // return指节点执行完completeWork后会返回的下一个节点，通常为父节点
  this.child = null
  this.sibling = null // 右边第一个兄弟节点
  this.index = 0

  this.ref = null

  // 保存本次更新造成的状态改变相关信息
  this.pendingProps = pendingProps
  this.memoizedProps = null
  this.updateQueue = null // 状态更新队列
  this.memoizedState = null
  this.dependencies = null

  this.mode = mode

  // Effects，render 相关
  this.flags = NoFlags
  this.subtreeFlags = NoFlags
  this.deletions = null

  // lanes 用来控制调度优先级
  this.lanes = NoLanes
  this.childLanes = NoLanes

  // 缓存相关
  this.alternate = null
}
```

### HostRootFiber

`HostRootFiber` 是使用 `createHostRootFiber` 创建的 Fiber 根节点，它包含整棵 Fiber 树信息。在源码内同 `rootFiber`，React 应用内可以同时存在多个 `rootFiber`。

### FiberRootNode

`FiberRootNode` 表示应用根节点，一个 React 应用内只有一个，在源码内也用 `FiberRoot` 表示。它保存着应用的状态和组件信息。

## render 阶段

render 阶段用于处理 React 内 workinprogress 树的计算和生成。在 React 源码内，render 开始于 `performSyncWorkOnRoot` 或者 `performConcurrentWorkOnRoot`，分别表示同步或者异步更新。

```js
// 同步更新 performSyncWorkOnRoot => renderRootSync => workLoopSync
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress)
  }
}

// 异步更新 performConcurrentWorkOnRoot => renderRootConcurrent => workLoopConcurrent
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress)
  }
}
```

可以看出，`workLoopSync` 和 `workLoopConcurrent` 都是循环执行 `performUnitOfWork` 方法，区别在于 workLoopConcurrent 能够通过 `shouldYield()` 方法来结束循环。**如果当前浏览器帧没有剩余时间，shouldYield 会中止循环，直到浏览器有空闲时间后再继续遍历。**

`workInProgress` 表示创建的 workInProgress Fiber Tree。

`performUnitOfWork` 方法会创建下一个 Fiber 节点并赋值给 workInProgress，两者共同构成 Fiber Tree。

### beginWork

每次循环 React Fiber 会进行深度优先遍历，每个被遍历到的节点会调用 `beginWork` 方法，该方法用于处理当前节点的更新逻辑。

beginWork 接受当前 Fiber 节点和 workInProgress Fiber 节点作为参数，目的是根据当前节点的类型，生成新的 Fiber 节点，在函数体内会判断本次是否需要更新/创建，以及是否有待更新的任务需要执行。由源码可以推断：

1. 如果希望执行更新，则需要设置 `didReceiveUpdate` 为 true；
2. 使用 `attemptEarlyBailoutIfNoScheduledUpdate` 来释放当前节点；

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null {
  // 判断当前节点是否需要更新，如果 current 不为 null，则说明当前节点已经存在，需要进行更新，否则需要进行创建
  if (current !== null) {
    // updated 阶段，比较当前节点内缓存的 props 和新的 props 是否发生变化
    const oldProps = current.memoizedProps
    const newProps = workInProgress.pendingProps
    // 判断 props 或者 context 是否发生变化，如果发生变化，则需要进行更新
    if (oldProps !== newProps || hasLegacyContextChanged()) {
      didReceiveUpdate = true
    } else {
      // 如果没有发生变化，则检查是否有待执行的 effect，如果有，则执行 effect，否则，直接释放
      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
        current,
        renderLanes
      )
      if (
        !hasScheduledUpdateOrContext &&
        (workInProgress.flags & DidCapture) === NoFlags
      ) {
        didReceiveUpdate = false
        return attemptEarlyBailoutIfNoScheduledUpdate(
          current,
          workInProgress,
          renderLanes
        )
      }
    }
  } else {
    didReceiveUpdate = false
    // 创建流程
    // 检查当前 workInProgress 是否有兄弟节点，即是否属于一个分叉子组件
    // 由此判断是否需要**在并行渲染线程**上渲染子组件，并代表一个新的渲染线程
    // pushTreeId 根据 workInProgress, numberOfForks（分叉数）, slotIndex（槽索引）计算新的
    // treeContextId、treeContextOverflow 以及 treeContextProvider，并将当前的数据压入栈中
    if (getIsHydrating() && isForkedChild(workInProgress)) {
      const slotIndex = workInProgress.index
      const numberOfForks = getForksAtLevel(workInProgress)
      pushTreeId(workInProgress, numberOfForks, slotIndex)
    }
  }

  // 如果是 mount 阶段，会根据 workInProgress.tag 的不同类型，新建不同的 Fiber 节点
  switch (workInProgress.tag) {
    case FunctionComponent: {
      // 函数组件
    }
    case HostRoot: {
      // 根节点
    }
  }
}
```

### HostRoot

在 beginWork 内，当 tag 为 HostRoot 时，表示当前节点为根节点，会执行 `updateHostRoot(current, workInProgress, renderLanes)` 进行根节点创建。

根据源码可以推断：

1. `workInProgress.pendingProps` 表示传入的 props，`workInProgress.memoizedState` 表示当前节点的状态，调用 `processUpdateQueue` 计算出新的状态；
2. `workInProgress.stateNode` 类型为 FiberRootNode，表示根节点，保存了应用的状态和组件信息；
3. `bailoutOnAlreadyFinishedWork` 用来跳过节点的比对过程，如果节点没有变动，则执行该方法来提升性能；
4. `reconcileChildren` 用来处理子节点的比对过程；

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress)

  if (current === null) {
    throw new Error('Should have a current fiber. This is a bug in React.')
  }

  const nextProps = workInProgress.pendingProps
  const prevState = workInProgress.memoizedState
  const prevChildren = prevState.element
  cloneUpdateQueue(current, workInProgress)
  processUpdateQueue(workInProgress, nextProps, null, renderLanes)

  const nextState: RootState = workInProgress.memoizedState
  const root: FiberRoot = workInProgress.stateNode
  pushRootTransition(workInProgress, root, renderLanes)

  if (enableCache) {
    const nextCache: Cache = nextState.cache
    pushCacheProvider(workInProgress, nextCache)
    if (nextCache !== prevState.cache) {
      // The root cache refreshed.
      propagateContextChange(workInProgress, CacheContext, renderLanes)
    }
  }

  const nextChildren = nextState.element
  if (supportsHydration && prevState.isDehydrated) {
    // 用户处理服务端渲染的情况，暂时不看
  } else {
    resetHydrationState()
    // 如果新的子节点和旧的子节点一样，=== 比较引用地址，相同表示没有变动，则不用继续处理了，直接跳过剩下的比对过程
    if (nextChildren === prevChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    }
    // 否则，需要继续处理子节点
    reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  }
  return workInProgress.child
}
```

## updateFunctionComponent

```js title="/packages/react-reconciler/src/ReactFiberBeginWork.js"
function updateFunctionComponent(
  current: null | Fiber,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes
) {
  let context
  if (!disableLegacyContext) {
    const unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
    context = getMaskedContext(workInProgress, unmaskedContext)
  }

  let nextChildren
  let hasId
  prepareToReadContext(workInProgress, renderLanes)
  if (enableSchedulingProfiler) {
    markComponentRenderStarted(workInProgress)
  }

  nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  )
  hasId = checkDidRenderIdHook()
  if (enableSchedulingProfiler) {
    markComponentRenderStopped()
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes)
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
  }

  if (getIsHydrating() && hasId) {
    pushMaterializedTreeId(workInProgress)
  }

  // React DevTools reads this flag.
  workInProgress.flags |= PerformedWork
  reconcileChildren(current, workInProgress, nextChildren, renderLanes)
  return workInProgress.child
}
```
