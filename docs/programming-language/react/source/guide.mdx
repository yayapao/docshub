---
id: guide
title: ''
sidebar_label: guide
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<DocsHeader
  title="Source code guide"
  description="从思想到框架，再到源码，抽丝剥茧了解 React 的秘密"
  github="https://github.com/facebook/react"
  tags={['React']}
  links={[
    {
      label: 'React 技术揭秘',
      link: 'https://react.iamkasong.com/preparation/idea.html#react%E7%90%86%E5%BF%B5',
    },
  ]}
/>

在本章节，我将更加深入阅读 React 源码，来探索 React 的秘密，从而更加深入地理解 React 的思想。

1. React 解决了什么问题？
2. React 做好了哪些工作，使它得以如此流行？

:::warning

本章节内容全部基于 `const ReactVersion = '18.3.0';` 版本。

:::

## React 解决的问题

在最开始，React 官方是这样描述 React 的：

:::note

React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。

:::

如何理解呢？我们知道应用的瓶颈无外乎**CPU 计算瓶颈和 IO 瓶颈**。 尤其是在浏览器运行时内，JS 线程和 GUI 渲染线程是互斥的，它们不能同时运行。众所周知，主流浏览器的刷新频率是 60HZ，即一帧的时间为 ≈16.6ms，在这个时间单元内，需要完成**JS 脚本执行 > 页面布局 > 样式渲染**。

当 JS 线程运行时间大于 16.6ms 时（一帧），就会出现卡顿现象，这就是 CPU 计算瓶颈。而 IO 瓶颈则是指网络请求、文件读写等操作，这些操作都是异步的，但是当它们执行完毕后，需要通知 JS 线程，这就需要 JS 线程不断地去轮询，这就是 IO 瓶颈。

为了解决上诉瓶颈，实现**快速响应**，React 内部实现了将同步更新转换为**异步可中断更新**的设计。这样，当 JS 线程执行时间过长时，就可以将控制权交还给 GUI 渲染线程，保证页面的流畅度，同时当执行完异步操作后，也可以通知 JS 线程，保证数据的一致性。

官网更新后，React 的描述变成了这样：

:::note

The library for web and native user interfaces

:::

它不再强调性能，而是强调了**跨平台**，这也是 React 未来的发展方向。

## React Fiber

React Fiber 是 React 16 中引入新的协调引擎（reconciler），对比之前的 Stack Reconciler，它是实现了**异步可中断更新**的关键。它的出现，使得 React 可以在不阻塞主线程的情况下，进行**增量渲染**，以达到更好的用户体验。

### 设计灵感

在我们深入了解 Fiber 架构之前，我们需要进行理论知识储备。

:::info 进程、线程、协程、纤程

- 进程（Processor）: 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位
- 线程（Thread）: 是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源
- 协程（Coroutine）: 是一种用户态的轻量级线程，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，切换回来时，恢复先前保存的寄存器上下文和栈，因此协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置
- 纤程（Fiber）: 有争议。

:::

_进程&线程_

关于以上知识，我们拓展一下，比如现在你有一个 API 服务跑在 80 端口上，实际上计算机就启动了一个进程，这个进程就是你的 API 服务，而这个进程中，可能有多个线程，比如你的 API 服务中有一个线程负责处理请求，一个线程负责写日志，一个线程负责读取数据库，这些线程都是在一个进程中，它们共享进程的资源，比如内存，文件句柄等。

_协程_

思考下 NodeJS 生态和 Go 生态，不难发现“天然”基于协程设计的 Goroutine，没有令人烦恼的 promise/async/await 这些异步方法的编写，同时也不会出现回调地狱，这就是协程的魅力。同时，协程更加轻量，非抢占式，不需要上下文切换（我理解是当程序执行时，协程切换不需要切换上下文指针，因为协程本身能够保留上一次的调用状态），不需要内核介入，所以它的性能更高。

#### 代数效应

:::info Algebraic Effects

代数效应是 React Fiber 实现的理论基础，它是一种计算机编程语言的特性，它可以将副作用（effect）从函数中分离出来，从而实现可中断的函数，可中断意味着可以复用中断之前的执行上下文（context），从而实现可中断的异步编程。

:::

**代数效应和协程的概念是不是很相似，都是用户控制，而不是系统控制，都是可中断的，都可以复用上下文，但是代数效应是一种理论，而协程是一种实现，代数效应可以实现协程，但是协程并不一定是代数效应。**

代数效用是针对函数式编程的概念，因为它解决的是函数式编程中特有的问题。它解决了函数 what 和 how 的耦合问题。举个例子：

现在我们需要实现一个函数，它的功能是从数据库中读取数据，然后将数据写入到文件中，那么我们可以这样实现：

```js
// readAndWrite 通过代码可以清楚看到它实现的功能，即 what is readAndWrite
function readAndWrite() {
  const conn = perform ConnectDB()
  const data = perform Read(conn)
  perform Write(data)
}
```

接下来我们实现 how 的部分：

```js
// 注意，这里 handle 只是为了表述方便，实际上并不是一个 js 实现
try {
  readAndWrite()
} handle (effect) {
  if (effect instanceof ConnectDB) {
    // ...
  } else if (effect instanceof Read) {
    // ...
  } else if (effect instanceof Write) {
    // ...
  }
}
```

#### React 和代数效应

**为什么 React 不使用 generator 实现代数效应？**

在 JS 生态内，Generator 函数就是一种协程，它可以通过 **yield 关键字**将函数的执行权交还给调用者，同时保留函数的上下文，这样就可以实现异步编程，但是 Generator 函数并不是一个完整的协程实现，它只是协程的一种语法糖，因为它需要**手动调用 next 方法**，而且**它的执行权只能交还给调用者，不能交还给其他函数**，所以从实现和编程语法上来说，它并不是一个完美的协程实现。

因为，React 提出 React Fiber 来进行更加完整的协程实现。**它是一套状态更新机制，支持不同任务优先级，能够中断和恢复，在恢复时可以复用之前的上下文，从而实现了可中断的异步编程。**

**已知 JavaScript 是单线程的，为什么还说 React Fiber？两种说法不是矛盾的吗？**

在 React 中，Fiber 是一种将可中断的任务切片处理的一种方式，这种方式可以被认为是一种协程，但是它并不是 JavaScript 中的协程，因为 JavaScript 是单线程的，它只是利用了浏览器的空闲时间来执行任务，这样就可以将一个大的任务拆分成很多小的任务，每次执行一个小任务，然后将控制权交还给浏览器，这样就可以实现**增量渲染**，从而提升用户体验。

### 核心工作原理-双缓存

:::warning 双缓存

在内存中构建，并完成替换的技术叫做双缓存

:::

想想如何没有双缓存会发生什么？用户产生交互后，浏览器先将新页面挂载，然后通过计算得出差异，再将差异更新到页面上，假设这个过程需要过量计算，或者在这个过程中用户产生了新的交互，那么就会出现明显的页面卡顿/闪烁的现象。

**而采用双缓存技术，我们可以将计算和渲染分离，在内容中构建出新的页面，之后直接替换旧的页面，这样就可以避免页面卡顿/闪烁的现象。**

![double-buffer.png](https://img.joyjoy.cc/react/double-buffer.png)

在 React 中，双缓存意味着最多需要维持两套 Fiber 树。一套是当前屏幕上显示内容的 Fiber 树，称为 current Fiber 树，另一套是准备渲染的 Fiber 树，称为 workInProgress Fiber 树。树与树之间，通过 `alternate` 属性进行连接。

React 应用的根节点为 **fiberRoot**，其 current 指针指向的树，就是 current Fiber Tree。一个 React 项目只有一个 fiberRoot。与之需要辨明得是 - **rootFiber**。通过调用 `ReactDOM.render` 方法创建的节点是 rootFiber，一个 React 项目内可以同时存在多个 rootFiber。

1. fiberRoot 通过改变 current 指针，能够将 current Fiber Tree 和 workInProgress Fiber Tree 进行切换，从而实现双缓存。这个过程发生在 `commit` 阶段；
2. workInProgress Fiber Tree 通过 `alternate` 属性，能够与 current Fiber Tree 进行连接。这个过程发生在 `render` 阶段；

## 本地调试

参考 [How to Contribute – React](https://legacy.reactjs.org/docs/how-to-contribute.html)，我们可以通过以下步骤进行本地调试：

1. `git clone git@github.com:facebook/react.git` 到本地；
2. 进入本地仓库后，执行 `yarn install` 安装依赖，**注意 node 版本需要满足 `"^12.17.0 || 13.x || 14.x || 15.x || 16.x || 17.x"`;**
3. 执行 `yarn build react/index,react/jsx,react-dom/index,scheduler --type=NODE` 编译原文件，构建产物位于 `/build/node_modules/` 目录下；
4. 依次进入 `react`, `react-dom` 以及 `scheduler` 目录，执行 `yarn link` 操作；

```bash
# 注意，现在产物位于 build/oss-stable 目录下，与官网有一定差异，其他产物同理
cd build/node_modules/react
yarn link

# link 成功后，会打印如下信息：
# yarn link v1.22.22
# success Registered "react".
# info You can now run `yarn link "react"` in the projects where you want to use this package and it will be used instead.
```

### 准备 JDK 环境

在执行 build 过程中，需要依赖 java runtime，因此需要确保 JDK 已安装，并且版本满足要求。这里我记录如何解决 MacOS 下，JDK 版本不匹配的问题。

在 build 过程中，发现 JDK Runtime 版本不满足要求，通过 `java -version` 查看，发现版本过低导致，因此需要升级 JDK 版本。

```bash
brew info openjdk

brew install openjdk

# 下载完成之后，进入 /Library/Java/JavaVirtualMachines 查看当前版本文件，之后将最新下载的版本通过软链接的方式进行替换
# 在此之前可以考虑删除 /Library/Java/JavaVirtualMachines 目录下的其他旧版本文件
sudo ln -sfn /usr/local/opt/openjdk@20/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdk

# 之后进入 /Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home 查看版本，发现版本已经更新
# 编辑 ~/.bash_profile 文件
touch .bash_profile
open -e .bash_profile

# 在文件中添加如下内容
JAVA_HOME="/Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home"
export JAVA_HOME
CLASS_PATH="$JAVA_HOME/lib"
PATH=".$PATH:$JAVA_HOME/bin"

# 刷新 .bash_profile 文件，即可完成替换
source .bash_profile
```
