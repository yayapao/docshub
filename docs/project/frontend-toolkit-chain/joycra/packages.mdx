---
id: packages
title: ''
sidebar_label: Packages
---

## zx

:::note zx
[zx](https://github.com/google/zx) 是一个 Google 的 util 脚本工具，基于 Node.js 的 child_process 对 shell 进行封装，能以接近 ES6 的语法来编写 bash 脚本
:::

我们通常在 `.mjs` 文件对编写 zx 脚本，它具备如下特性：

- 支持大部分的 node.js 特性和语法
- 能够转换 [bash 命令](https://github.com/google/zx#functions)
- 内置编写脚本的[常用依赖](https://github.com/google/zx#packages)

这里我们直接以一个例子开始：

```js
#!/usr/bin/env zx

import dayjs from 'dayjs'

const log = console.log
const ALERT_MESSAGE = '\nPlease confirm your input!\n'
const cmds = ['tag']

/**
 * 判断是否传递命令行参数
 * 如果传递，则直接获取参数，并将其丢入 switch 内进行判断
 * 如果没传递，则通过 question(readline) 来引导用户传入
 * 注意：两种方式获取的参数类型不一样，前者为数据，后者为空格拼接的字符串
 */
const [nodePath, zxPath, scriptName, ...restData] = process.argv
let choose
if (!restData || restData.length === 0) {
  const crt = await question('Choose command: ', {
    choices: cmds,
  })
  // 处理字符串
  choose = crt.split(' ')
} else {
  choose = restData
}

// 根据参数进行路由判断
const [target, ...rest] = choose
switch (target) {
  case 'tag':
    tag(...rest)
    break
  default:
    log(chalk.red(ALERT_MESSAGE))
    log(`Support command ===> ${cmds.join(' ')}`)
}

// 生成 tag，并推送到 git
async function tag(name) {
  let tagName = name

  if (!name) {
    const COMMIT_ID = await $`git rev-parse --short HEAD`
    const COMMIT_NAME = String(COMMIT_ID).trim()
    tagName = COMMIT_NAME
  }

  log(chalk.blue(`Tag name is ${tagName}`))
  const dt = dayjs().format('YYYY-MM-DD HH:mm:ss')
  await $`git tag -a ${tagName} -m "Created at ${dt}"`
  await $`git push --tag`
  log(chalk.black.bgGreen.bold(`Successfully tag at ${Date.now()}`))
}
```

如上脚本所示，我们在一行申明 <HighlightWithCode>#!/usr/bin/env zx</HighlightWithCode> 之后，就可以编写相关的执行脚本，通过 <HighlightWithCode>const res = await $`bash command`</HighlightWithCode>的形式来执行原生 bash 命令，同时我们会根据用户输入的命令行参数来执行不同的动作。

### 如何获取命令行内参数？

在执行类似 `zx control.mjs build params1 params2` 命令时，我们可以通过 [node.js-process.argv](http://nodejs.cn/api/process/process_argv.html) 来获取执行参数

相较于 `node control.js` 直接执行指定脚本的形式，通过 zx 执行会存在一点区别：通常来说，`process.argv` 返回一个指定顺序的数组：

1. 第一个元素是 `process.execPath`, 通常是 node 的执行文件路径；
2. 第二个元素是正在执行的 javascript 文件，由于 zx 作为中间层，因此在执行 zx 脚本时，指向的是 zx 的执行文件路径，**区别就在于此**；
3. 剩下的会按照顺序依次填入数组；


## Axios

> [axios](https://github.com/axios/axios) 现在是一种常见的客户端数据请求库，它基于 XMLHttpRequest 和 Promise

### 取消重复请求

核心思想利用`set`数据结构，维护一个 pending set，里面存放 key(通过 url.config 拼接)和 value(取消改请求的 cacel 方法)

```js
import axios from 'axios'
import { message } from 'ant-design-vue'

// 声明一个 Map 用于存储每个请求的标识 和 取消函数
const pending = new Map()

// 通过工厂方法创建 canceltoken，用于取消用户请求
let CancelToken = axios.CancelToken
let source = CancelToken.source()

// axios 实例
let service = axios.create({
  //   baseURL: "/service/",
  timeout: 60000,
  headers: {},
  withCredentials: true,
})

const addPending = (config) => {
  const url = [
    config.method,
    config.url,
    JSON.stringify(config.params),
    JSON.stringify(config.data),
  ].join('&')
  config.cancelToken =
    config.cancelToken ||
    new axios.CancelToken((cancel) => {
      if (!pending.has(url)) {
        // 如果 pending 中不存在当前请求，则添加进去
        pending.set(url, cancel)
      }
    })
}

const removePending = (config) => {
  const url = [
    config.method,
    config.url,
    JSON.stringify(config.params),
    JSON.stringify(config.data),
  ].join('&')
  if (pending.has(url)) {
    // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除
    const cancel = pending.get(url)
    cancel(url)
    pending.delete(url)
  }
}

export const clearPending = () => {
  for (const [url, cancel] of pending) {
    cancel(url)
  }
  pending.clear()
}

// 设置请求拦截器
service.interceptors.request.use(
  (config) => {
    removePending(config) // 在请求开始前，对之前的请求做检查取消操作
    addPending(config) // 将当前请求添加到 pending 中
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 设置响应拦截器
service.interceptors.response.use(
  (response) => {
    removePending(response.config) // 在请求结束后，移除本次请求
    return response
  },
  (error) => {
    if (axios.isCancel(error)) {
      // 再次尝试 cancel
      console.error(error.message)
    }
    return Promise.reject(error)
  }
)

/**
 * config.params 用来接受查询参数
 */
async function get(url, config = {}) {
  try {
    const response = await service.get(url, config)
    // 返回服务器传值
    return response.data
  } catch (e) {
    throw e
  }
}

/**
 * params 用来接收查询参数
 */
async function post(url, params, config = {}) {
  try {
    const response = await service.post(url, params, config)
    // 返回服务器传值
    return response.data
  } catch (e) {
    throw e
  }
}

export { get, post }
```