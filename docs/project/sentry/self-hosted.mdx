---
id: self_hosted
title: 私有化部署
sidebar_label: self hosted
---

import { HighlightWithText } from '../../../src/components/Highlights'

对于开源项目，出于数据安全和功能拓展的考虑，我们一般会选择私有化部署。在本章节，我们将讨论私有化部署 Sentry 的解决方案。

## TroubleShooting

<HighlightWithText>Q: 在本地创建项目时，发现 `POST /api/0/teams/sentry/sentry/projects/` 报错 `400 invaild platform` ?</HighlightWithText>

查看源码发现程序需要读取 `integration-docs` 目录下的文件，返回静态页面

通过执行 `sentry repair --with-docs` 拉取最新的集成列表，安装在本地的 sentry 内

<HighlightWithText>Q: 上报域名返回大量500?</HighlightWithText>

可能是 relay 服务的不足以处理突然暴增的上报请求，可以尝试扩容。但是扩容后同样可能导致后续事件对列堆积，更好是针对指定应用进行客户端+服务端限流

<!-- -->

## 官方解决方案

参考[官方推荐私有化部署](https://github.com/getsentry/self-hosted)，它是将 Sentry 依赖的各个服务挂载到 Docker 上，通过 Docker-compose 来统一管理

系统要求：
- Docker 19.03.6+ 
- Compose 1.28.0+
- 4 CPU Cores
- 8 GB RAM
- 20 GB Free Disk Space

部署流程参考官方文档即可。官方推荐的私有化方式能够快速部署上线，但是由于整个服务部署在单机上，无法灵活地扩容，性能瓶颈十分明显。因此在实际生产中，我们并没有直接采纳该方案，而是将其各个服务拆解出来，独立部署

## 改进方案

出于系统吞吐量和性能稳定性的考虑，我们将根据官方方案对各个服务进行拆解，独立部署

:::info why this way works?
因为 sentry 本身基于 redis 和 Kafka 等数据服务来进行事件流的通信和处理，业务服务之间并未直接依赖
:::



## 本地开发

更进一步地，我们希望具备基于源码进行拓展和优化的能力，因此我们需要具备本地开发的能力。接下来我参考[官方文档](https://develop.sentry.dev/environment/)对实际部署流程进行介绍

### 运行时依赖

源码

- 从 [sentry](https://github.com/getsentry/sentry) 内 clone 项目到本地，这里**建议选择最新的稳定 release 版本**

MacOS 基础环境

- 执行 `xcode-select --install` 或者启动 Xcode 更新 Xcode CLI tools，目的是安装 MacOS 的基础开发环境
- 进入 sentry 本地目录，执行 `brew bundle --verbose` 安装在 Brewfile 内列出的各种软件

Python 依赖

- Sentry 依赖 [python wheels](https://pythonwheels.com/)，它包含一些二进制包，需要保证 MacOS 版本较新且本机内安装有 Rust 执行环境
- Sentry 利用 [pyenv](https://github.com/pyenv/pyenv) 来安装和管理 python 版本，执行 `brew install pyenv` 安装一下，之后执行 `make setup-pyenv` 安装 Sentry 依赖环境
  - 安装完成之后，执行 `which python` --> 预期出现 `/usr/bin/python`
  - 修改 `bash_profile`，添加 `#pyenv \n eval "$(pyenv init -)" \n export PATH="$HOME/.pyenv/bin:$PATH"` 来指定路径
  - 执行 `eval "$SHELL"` **重启控制台特别关键**
  - 再次执行 `which python` --> 预期出现 `/Users/you/.pyenv/shims/python`，相当于做了一次拦截，将 python 命令托管给 pyenv 后统一处理
  - 在 sentry 根目录下，执行 `python -m venv .venv` 创建 python 项目虚拟执行路径
  - `source .venv/bin/activate` 启用运行环境
  - 此时在虚拟环境内执行 `which python` --> 预期出现 `/Users/you/sentry/.venv/bin/python`

Node.js 依赖

- Sentry 依赖 [volta](https://github.com/volta-cli/volta) 来安装和管理 Node.js 版本
  - 执行 `curl https://get.volta.sh | bash` 来 install volta
  - 执行 `eval "$SHELL"` 来重启控制台，**真的很重要**
  - 修改 `bash_profile`，添加 `export VOLTA_HOME="$HOME/.volta" \n export PATH="$VOLTA_HOME/bin:$PATH"`

管理环境变量

- Sentry 依赖 [direnv](https://github.com/direnv/direnv) 来自动激活你的虚拟环境，设置一些必要的环境变量，并且会自动检测你的环境是否可用
  - 执行 `brew install direnv` ，之后在 `.zshrc` 文件末尾添加配置 `eval "$(direnv hook zsh)"`
  - 执行 `eval "$SHELL"` 重启控制台


执行 `make bootstrap` 来启动项目，在 Docker Dashboard 内观察 Sentry 服务的运行情况，理论上会启动：

- `sentry_relay`
- `sentry_snuba`
- `sentry_kafka`
- `sentry_zookeeper`
- `sentry_postgres`
- `sentry_redis`
- `sentry_clickhouse`

### 运行 Sentry

在本地仓库内，重点观察 `Makfile`, `setup.py` 文件，下面介绍运行命令：

- 执行 `make bootstrap` 在 docker 内启动服务
- 执行 `sentry help` 查看相关命令

:::caution --workers
如果需要走通 sentry 上报的全部流程(即启动所有服务)，需要执行 `sentry devserver --workers`
:::

#### 打包构建

这里我们参考源仓库的 `/docker/builder.*` 文件来查看构建流程，基于此，我们开发了一个构建脚本：

```bash
function build() {
  set -e

  if [[ ! -f setup.py ]]; then
      >&2 echo "Cannot find setup.py, make sure you have mounted your source dir to /workspace"
      exit 1
  fi

  # fe env
  cd ./js
  yarn install --frozen-lockfile --production --quiet

  # fe package
  cd ../
  mv ./node_modules ./node_modules_backup
  rm -rf ./dist
  mkdir ./node_modules
  echo "Populating node_modules cache..."
  cp -R ./js/node_modules/* ./node_modules/

  # py env
  pip3 install pkginfo==1.5.0.1
  pip3 install wheel

  # py package
  export YARN_CACHE_FOLDER="$(mktemp -d)"
  python setup.py bdist_wheel --build-number 0
  rm -r "$YARN_CACHE_FOLDER"
  pkginfo -f requires_dist --single --sequence-delim=! dist/*.whl | tr ! \\n > dist/requirements.txt

  # output dist.tar.gz
  tar -zcvf dist.tar.gz ./dist/*
  rm dist.tar.gz

  # recover node_modules
  rm -rf ./node_modules
  mv ./node_modules_backup ./node_modules

  # other handles...
}
```

最终会在 dist 目录下生成 `requirements.txt` 和 `sentry-[sentry version]-[python version]-none-any.whl` 文件


