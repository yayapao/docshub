---
id: sourcecode
title: Sentry Source Code
sidebar_label: source code
---

import { HighlightWithText } from '../../../src/components/Highlights'

## Customized OpenAPI

:::note OpenAPI
自定义 OpenAPI
:::

**Why need to customized openAPI?**

我们希望基于采集数据做 sentry 尚未完备的分析和探索，因此我们需要提供接口来关联数据、分析数据以及对外提供服务。

为什么直连 clickhouse 进行分析？

- 权限，sentry 通过 API token 来解决 openAPI 的权限问题
- 架构复杂性，我们并不希望开启一个新的后端服务来做 sentry 内已兼备的工作
- 性能问题，CK 并不擅长做查询操作，并且 sentry 已经做了大量的工作来保证查询性能

Sentry 的 API 服务是基于 [django](https://www.djangoproject.com/) 实现。这里结合 sentry 对其基本点进行归纳：

- 路由配置位于 `src/sentry/api/urls.py`，遵循 `url(RegExp, View, name)` 的形式进行声明
- View 通常继承自 `[模块基类] > base.py > view.py`，以 project-event 为例，其位于 `src/sentry/api/endpoints/project_events.py`，类继承自 `ProjectEndpoint` 基类

## Processor

这里以[List a Project's Events](https://docs.sentry.io/api/events/list-a-projects-events/)接口为例进行源码探寻，我们试图弄清楚：
1. sentry 内 OpenAPI 的组织形式；
2. 如何自定义 API 并使用其 auth 和数据查询能力；




## SourceMap

:::note sourcemap
保存源码映射关系
:::

**Why sourcemap?**

在现代开发环境中，在应用上线到生产环境之前，我们往往需要对代码进行各种编译、优化处理，这将导致生产环境的代码不同于开发环境。尤其伴随着工程化的日益成熟，模块化已经是开发的常用方案。但是，处理后的代码会给我们在 debug 或者问题排障时会带来困扰。

因此需要一种机制，既能保证线上的发布流程，同时也能兼顾我们 debug 的需求，[sourcemap](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?hl=en_US&pli=1&pli=1#heading=h.1ce2c87bpj24)应运而生。

Sentry 基于 sourcemap 提供了快速定位源码的能力。

### sentry processor

sentry 会对源文件和 SourceMap 单独进行处理，处理关键步骤在于如何缓存和读取文件内容。其中缓存文件时会使用到 `cache_key`(对应文件内容) 和 `cache_key_meta`(对应文件元信息)，而使用读取内容时会遵循**缓存 - database - internet**的顺序。

本章，我们会对 sentry 加工 frames 的过程进行阅读，并记录异常处理，以方便对生产问题进行排查。


![sourcemap_processor](/img/fte/sourcemap.svg)

#### 处理源文件

从 frames 内容中提取出文件地址后：

- `frames.abs_path` 不存在
- `frames.abs_path` 为 `<anonymous>`
- 平台为 node 并且源文件路径不以 `app:` 开头
- `frames.abs_path` 太长导致被省略号占位
- 未配置 release 或者 release 文件为空的前提下，关闭 `Allow JavaScript Source Fetching` 或者 `frames.abs_path` 不是以 `http:` 或者 `https:` 开头
- 请求源文件失败
- 拿到源文件内容后，如果不是 bytes，需要对其进行编码，如果此步骤报错，返回 `FETCH_GENERIC_ERROR` 错误
- 拿到源文件内容后，如果不是 JavaScript/JSON 文件，则会返回 `FETCH_GENERIC_ERROR` 错误

<HighlightWithText text="populate_source_cache()" />{' '}

```python
def populate_source_cache(self, frames):
  pending_file_list = set()
  for f in frames:
    if f.get("abs_path") is None:
        continue
    if f["abs_path"] == "<anonymous>":
        continue
    if self.data.get("platform") == "node" and not f.get("abs_path").startswith("app:"):
        continue
    pending_file_list.add(f["abs_path"])
```

<HighlightWithText text="fetch_file()" />{' '}

```python
# url = abs_path
def fetch_file(url, project=None, release=None, dist=None, allow_scraping=True):
    if url[-3:] == "...":
        raise http.CannotFetch({"type": EventError.JS_MISSING_SOURCE, "url": http.expose_url(url)})

#...
# 未配置 release 或者没找到 release 的 artifact 会导致 result 为 None
    if result is None:
        if not allow_scraping or not url.startswith(("http:", "https:")):
            error = {"type": EventError.JS_MISSING_SOURCE, "url": http.expose_url(url)}
            raise http.CannotFetch(error)

#...
# 请求文件失败
    if result.status != 200:
        raise http.CannotFetch(
            {
                "type": EventError.FETCH_INVALID_HTTP_CODE,
                "value": result.status,
                "url": http.expose_url(url),
            }
        )
#...
# 编码文件失败，Unable to fetch HTTP resource
if not isinstance(result.body, bytes):
    try:
        result = http.UrlResult(
            result.url,
            result.headers,
            result.body.encode("utf8"),
            result.status,
            result.encoding,
        )
    except UnicodeEncodeError:
        error = {
            "type": EventError.FETCH_INVALID_ENCODING,
            "value": "utf8",
            "url": http.expose_url(url),
        }
        raise http.CannotFetch(error)

#...
# 如果不是 JavaScript/json 文件，Unable to fetch HTTP resource
if urlsplit(url).path.endswith(".js"):
    body_start = result.body[:20].lstrip()
    if body_start[:1] == b"<":
        error = {"type": EventError.JS_INVALID_CONTENT, "url": url}
        raise http.CannotFetch(error)
```

#### 处理 SourceMap

处理完源文件，并返回文件结果后，首先尝试用源文件内容中获取 sourcemap 索引地址，遵循 `header > force_bytes(sourcemap) > sourceMappingURL=` 的寻找顺序，如果找到，会将其 `filename-sourcemap_url` 键值对写入缓存，否则直接返回（不会报错）

之后，会根据 sourcemap_url 去调用 `fetch_file()` 方法请求指定 sourcemaps。因此在排障时我们可以从以下方面入手：

- 请求源文件内容
- `sourceMappingURL` 是否解析正确
- 生成 sourcemap 地址是否正确
- 请求 sourcemap 文件内容

值得注意的是生产 sourcemap url 的方法：

```python
_scheme_re = re.compile(r"^([a-zA-Z0-9-+]+://)(.*)$")


def non_standard_url_join(base, to_join):
    """A version of url join that can deal with unknown protocols."""
    if not to_join:
        return base

    match = _scheme_re.match(to_join)
    if match is not None:
        return to_join

    match = _scheme_re.match(base)
    if match is not None:
        original_base_scheme, rest = match.groups()
        base = "http://" + rest
    else:
        original_base_scheme = None

    rv = urljoin(base, to_join)
    if original_base_scheme is not None:
        match = _scheme_re.match(rv)
        if match is not None:
            return original_base_scheme + match.group(2)

    return rv
```
