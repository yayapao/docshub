---
id: metrics
title: Web Metrics
sidebar_label: Web Metrics
slug: metrics
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import {
  HighlightWithText,
  HighlightWithBadge,
  VitalStandard,
} from '@site/src/components/Highlights'

Web 指标是 Google 在 2020 左右发布的一项新计划，旨在为应用质量衡量提供统一标准，为此，它定义了大量的 web 指标。 这里我们按照重要程度对 web 指标进行分类：

:::info web metrics

1. 核心指标：我们继续沿用 Google 对 [Core Web Vitals](https://web.dev/vitals/#core-web-vitals) 的定义，即 LCP、FID 和 CLS
2. 重要指标：

:::

## Core Web Vitals

对于核心指标，Google 提出了三个最<HighlightWithBadge label="核心" />的指标：LCP、FID 和 CLS，分别对应加载性能、可交互性以及视觉稳定性。同时以用户为中心为其制定<HighlightWithBadge label="衡量标准" />

<HighlightWithText>如何理解核心?</HighlightWithText>

- 这三个指标不仅能够被实际测量，并且适用于所有网页应用，更关键的是，它们能够反映**以用户为中心**的关键结果的真实体验，即 RUM 指标。

<HighlightWithText>如何定义页面可用？</HighlightWithText>

<!-- fix Highlights -->

简而言之，页面存在足够的元素让用户可以交互，则认为该页面[可用](https://web.dev/user-centric-performance-metrics/#questions)，LCP 是衡量页面是否可用的核心指标

<HighlightWithText>衡量标准</HighlightWithText>

<!-- fix Highlights -->

为了确保 web 应用的大部分访问用户能够达成建议目标值，通常取采样数的 **75 分位**

- <VitalStandard label="LCP" good="<2.5sec" improve="2.5~4sec" bad=">4sec" />
- <VitalStandard label="FID" good="<100ms" improve="100~300ms" bad=">300ms" />
- <VitalStandard label="CLS" good="<0.1" improve="0.1~0.25" bad=">0.25" />

:::caution
各个指标的衡量指标具有广泛的指导意义，但是对于特殊的应用其阈值可以动态调整
:::

<!-- fix Highlights -->

### LCP

[LCP](https://web.dev/lcp/)（Largest Contentful Paint：最大内容绘制） 用来衡量页面加载性能。

LCP 度量从用户进入 web 应用到在可视区域内渲染最大可见内容元素所需的时间。最大可见内容元素通常是图片或视频，也可能是大型块级文本元素。

为什么选用 LCP 作为衡量标准?

很大程度是因为其他指标不够准确，比如当进入页面先加载一个 loading 效果，即使主要内容还没加载出来，此时页面会认为已经完成了 load 、DOMContentLoaded 或者被捕获到 FCP 指标。因为 Google 选择使用 LCP 来作为 RUM 加载性能的衡量标准，为此也给了一个经典的解释：

> "Sometimes simpler is better. A more accurate way to measure when the main content of a page is loaded is to look at when the largest element was rendered!"

在弄清楚 LCP 是什么、其衡量标准以及选择 LCP 作为加载性能指标之后，我们还需要清楚：

- 如何确定一个元素的大小？
- 何时报告 LCP?
- 元素或者页面布局更改了怎么处理？

对于以上问题，我归纳了一些技术点，具体内容还是建议参考[LCP 官方文档](https://web.dev/lcp/)

:::note 关键

- LCP 计算可视区域内**初始元素的尺寸**，而不是 size，如果元素尺寸发生变化，始终取较小的尺寸。例如，远小于其原始尺寸的缩小图像将仅报告图像的显示尺寸，而拉伸或放大成更大尺寸的图像将仅报告图像的原始尺寸
- LCP 的值会随着页面加载而发生改变，并且始终以更大的元素作为当前值，在分析时，取最近的 LCP 即可

:::

#### 如何在浏览器 runtime 采集 LCP？

通常情况下，我们直接使用官方的[web-vitals](https://github.com/GoogleChrome/web-vitals)即可，这里出于学习目的对其源码进行解读：

通过对浏览器提供的 [PerformanceObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver/PerformanceObserver) API 进行封装，来捕获指定的观测类型。对于 LCP、FID 以及 CLS 等指标均适用，其实现如下：

```typescript
// observe.ts 定义指标监控通用方法
export const obverse = (
  type: string,
  callback: PerformanceEntryHandler
): PerformanceObserver | undefined => {
  try {
    // 验证是否支持监听该类事件
    if (PerformanceObserver.supportedEntryTypes.includes(type)) {
      const po: PerformanceObserver = new PerformanceObserver((l) =>
        l.getEntries().map(callback)
      )

      po.observe({ type, buffered: true })
      return po
    }
  } catch (e) {
    // Do nothing.
  }
  return
}
```

通过对应用加载过程中 **largest-contentful-paint** 类型进行监听。在 `entryHandler` 方法内对值进行比较、替换。

```typescript
const entryHandler = (entry: PerformanceEntry) => {
  // The startTime attribute returns the value of the renderTime if it is not 0,
  // and the value of the loadTime otherwise.
  const value = entry.startTime

  // If the page was hidden prior to paint time of the entry,
  // ignore it and mark the metric as final, otherwise add the entry.
  if (value < visibilityWatcher.firstHiddenTime) {
    metric.value = value
    metric.entries.push(entry)
  }
  report()
}

// 在 getLCP.ts 内调用 observe 方法，entryHandler 用来赋值
const po = observe('largest-contentful-paint', entryHandler)
```

在页面 hidden 时或者用户产生交互事件时，捕获 entry 并进行上报，触发自定义回调

```typescript
const stopListening = () => {
  // 如果定义的 metric 采集器内含有 LCP 指标，则将其记录加入到 finalMetrics 内，之后调用自定义函数
  if (!finalMetrics.has(metric)) {
    po.takeRecords().map(entryHandler as PerformanceEntryHandler)
    po.disconnect()
    finalMetrics.add(metric)
    report()
  }
}

;['keydown', 'click'].forEach((type) => {
  addEventListener(type, stopListening, { once: true, capture: true })
})

onHidden(stopListening, true)
```

不难看出，为了采集指标的准确性，需要对用户已经产生交互/页面隐藏的情况特别注意！

### FID

[FID](https://web.dev/fid/)（First Input Delay：首次输入延迟） 用来衡量页面的交互性。

FID 度量用户进入 web 应用并产生交互（点击链接、点按按钮等等）动作到浏览器响应并能够实际处理此次交互的耗时。这种衡量方案的对象是被用户首次点击的任何互动式元素。

为什么选用 FID 作为衡量标准?

用户对 web 应用的第一印象不仅仅是元素绘制的速度，当需要与应用进行交互式，可交互度也是一个重要的衡量标准。用户输入延迟不可避免，因此 FID 被选中，因为核心指标需要它。

对于 FID 我们需要清楚：

- 为什么会发生输入延迟？
- 什么是首次输入？
- 为什么只考虑首次输入？

:::note 关键

- FID 测量的是发起事件处理后到浏览器执行处理程序前所花费的时间，边界要清楚，不将其他环节纳入进来的原因是担心开发者为了优化而优化
- 首次输入是非连续性的交互行为，侧重 response，而滚动、缩放属于连续性的交互，具有完全不同的性能约束（即执行机制）

:::

#### 如何在浏览器 runtime 采集 FID？

在讨论如何在浏览器运行时采集 FID 之前，我们先观察这个经典 FID 过程，测量 FID 实际上就是计算用户输入到主线程完全空闲的耗时

![fid](/img/wpm/fid.svg)

参考 [web-vitals](https://github.com/GoogleChrome/web-vitals) 我们不难看出，FID 的测量主要通过采集 `first-input` 事件，对其进行处理

```typescript
const entryHandler = (entry: PerformanceEventTiming) => {
  // Only report if the page wasn't hidden prior to the first input.
  if (entry.startTime < visibilityWatcher.firstHiddenTime) {
    metric.value = entry.processingStart - entry.startTime
    metric.entries.push(entry)
    report(true)
  }
}

const po = observe('first-input', entryHandler as PerformanceEntryHandler)
```

### CLS

[CLS](https://web.dev/cls/)（Cumulative Layout Shift：累积布局偏移） 用来衡量页面视觉稳定性，用来量化用户经历意外布局偏移的频率。

CLS 会衡量 web 应用在整个生命周期内发生的所有意外布局偏移中的**最大一连串的布局偏移分数**。得分是零到任意正数，其中 0 表示无偏移，且数字越大，网页的布局偏移越大。

为什么选用 CLS 作为衡量标准？

大多数情况下，用户希望 web 应用是“所见即所得”的，如果目标元素经常偏移（位置经常发生变化），这无疑是很恼火的。累积布局偏移 (CLS) 是测量视觉稳定性的一个以用户为中心的重要指标，因为该项指标有助于量化用户经历意外布局偏移的频率。

对于 CLS 我们需要清楚：

- 如何定义布局偏移和累积布局偏移？
- 如何计算布局偏移分数？

:::note 关键

- CLS 针对不稳定元素进行计算
- 可见区域内的元素在不同帧的位置发生变化，则该页面发生了布局偏移
- 只有当现有元素的起始位置发生变更时才算作布局偏移，新增元素不算在内
- 影响分数和距离分数都是基于可视区域
- CLS 仅计算用户连续输入事件，比如点击、按键

:::

#### 如何在浏览器 runtime 采集 CLS?

相比 LCP 和 FID，CLS 的计算会稍显复杂，它同样通过 `obverse` 对 **layout-shift** 指标进行采集。

```typescript
let sessionValue = 0;
let sessionEntries: PerformanceEntry[] = [];

const entryHandler = (entry: LayoutShift) => {
  // CLS 仅计算用户连续输入事件，用户输入 500ms 内发生的布局偏移会带有 hadRecentInput 标志
  if (!entry.hadRecentInput) {
    const firstSessionEntry = sessionEntries[0]
    const lastSessionEntry = sessionEntries[sessionEntries.length - 1]

    // 每次偏移时间小于 1s 且整个会话最大持续时间小于 5s 的数据会被采集
    if (
      sessionValue &&
      entry.startTime - lastSessionEntry.startTime < 1000 &&
      entry.startTime - firstSessionEntry.startTime < 5000
    ) {
      sessionValue += entry.value
      sessionEntries.push(entry)
    } else {
      sessionValue = entry.value
      sessionEntries = [entry]
    }

    // 这里不再进行累计，而是取窗口内 CLS 的最大值
    if (sessionValue > metric.value) {
      metric.value = sessionValue
      metric.entries = sessionEntries
      report()
    }
  }
}

const po = observe('layout-shift', entryHandler as PerformanceEntryHandler)
```


## 重要 Web 指标

重要 web 指标用来对 core web vitals 进行补充，它们既包含实验室指标，也会包含真实用户指标，定义这些指标有助于获取范围更广的体验或者帮助诊断特定问题。

### TTFB

### FCP

### TBT

### TTI

