---
id: linux
title: ''
sidebar_label: Linux
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'

<DocsHeader
  title="System && SHELL"
  description="Learning Linux from practice."
  tags={['Linux', 'Bash', 'Shell']}
  links={[
    {
      label: 'Linux 教程',
      link: 'https://www.runoob.com/linux/linux-tutorial.html',
    },
  ]}
/>{' '}

:::tip

明晰概念，积累系统相关速查表。

:::

## command 速查表

| command                    |                                             description |
| :------------------------- | ------------------------------------------------------: |
| ps -ef                     |                                  展示所有进程的详细信息 |
| ps -xf                     |                          展示当前用户相关进程的详细信息 |
| df -h                      |                                  展示系统内磁盘占用空间 |
| du --max-depth=1 -h [path] | 查看指定目录下，每个目录占用空间 (macos: du -d 1 -h ./) |
| du -sh [path]              |                                  查看指定目录的占用空间 |
| date +"%s"                 |                                      返回系统当前时间戳 |
| date +"%F %T"              |            输出执行格式时间字符串 “DDDD-YY-MM HH:mm:ss“ |

- `ps(process status)` 用于查看当前主机内运行的服务状态
- `du(disk usage)` 用于展示文件/目录占用磁盘空间大小
- `date` 用来设定或者展示系统时间
- `top` 查看当前系统进程信息（但是在容器内，该命令并不准确，需要去文件内查看真是内存使用）
  - M - 按照内存倒序
  - P - 按照 CPU 使用率倒序

## Shell 术语整理

在 Linux 内，我们通常混淆 Ternimal, Shell, zsh, CLI, GUI 等名词。

![what-is-shell.png](https://img.joyjoy.cc/os/what-is-shell.png)

1. 相较于编译，**解释 = 编译 + 虚拟机**，编程语言没有编译和解释的说法，只能说某个编程语言是编译后执行还是通过解释器解释执行
2. item2 => Ternimal, 也就是黑框框，通过配置 iterm2 配置，可以更改框框的表现
3. bash,zsh => Shell，shell 运行在 ternima 中，shell 是一个命令解释器，通过内置解释器对输入命令进行解释，从而调用系统 API。**理论上，一个具有解释器的编程语言，都可以被称为 Shell，比如 Node.js**
4. z,npm => CLI（Command Line Interface），通过参考其源码可以发现，CLI 表现为 Shell 脚本

## Shell Programming

### 变量命名规则和使用

规则：

- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头
- 中间不能有空格，可以使用下划线
- 不能使用标点符号
- 不能使用 bash 里的关键字（可用 help 命令查看保留关键字）

在 Linux 内，变量是一个键值对，直接访问变量名返回的是变量名，通过 `${变量名}` 访问其值

```bash
# 声明变量 name 的值为 “papaya”
name = "yayapa"

# 通过 ${...} 使用变量
echo ${name}

# 通过 `-e` 支持不转义
echo "Hello, $name\n"

# readonly 设置变量只读
readonly read_name = "cool"

# 删除变量，只读变量不能删除
unset name

# 定义数组，通过换行或者空格进行分隔
array=(value0 value1 value2 value3)

# 获取所有元素
${array[*]}

# 获取元素个数
length=${#array[*]}

# 获取元素值
valuen=${array[n]}
```

### `&` vs `&&`

在 Linux 中，`&` 放在命令末尾表示：**将该命令放到后台执行，** 主进程将继续向下执行，被放入后台命令将与主进程并行执行。

`&&` 与单纯换行的实际效果一致，等待当前命令执行完毕之后，再继续执行后面的命令。

### 大小判断

大于(greater than) `-gt`

小于(less than) `-lt`

大于或等于(greater than or equal) `-ge`

小于或等于(less than or equal) `-le`

不相等(not equal) `-ne`

### if elif 控制

`fi` 用于终止代码块

```sh
if [[ $option_select -eq 1 ]]; then
	# statements...
elif [[ $option_select -eq 1 ]]; then
	# statements...
fi
```

### 类型判断

**数字类型判断**

```sh
# 判读输入值是否为一个数字，如果为0，则证明是一个数字类型
expr $sort "+" 10 &> /dev/null

if [[ $? -eq 0 ]]; then
	# statements...
```

**字符串判断**

```shell
a="abc"
b="cde"

# = / != 判断是否相等
[$a=$b]

# -z 判断字符串长度是否为 0
[-z $a]

# -n 判断字符串是否不为空
[-n $a]

# $ 判断字符串是否为空
[$a]
```

### 定义函数

在 Linux 内通过 `function` 声明函数：

- 函数传参通过空格进行分隔
- 函数内通过 `$` 来获取传递参数，比如 `$1` 用来获取第一个传参，`$?` 获取上一个传值

```Bash
#!/usr/bin/env bash

# declare function
# 3 params 1. title 2. array options 3. array's length
function READ_USER_INPUT() {
  title=$1
  options=$2
  maxValue=$3
  echo "${title}"

  # 遍历数组
  for option in ${options[*]}; do
    echo "${option}"
  done

  read sort
  return ${sort}
}

# call the function
options_value=("1.start" "2.stop" "3.list")
READ_USER_INPUT "this is title" "${options_value[*]}" ${#options_value[*]}

# get the return value
option_select=$?
```
