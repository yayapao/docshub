---
id: axios
title: ''
sidebar_label: axios
---

import { DocsHeader } from '/src/components/Layout/DocsHeader'
import { HighlightWithText } from '/src/components/Highlights'

<DocsHeader
  title="Axios"
  description="Promise based HTTP client for the browser and node.js!"
  github="https://github.com/axios/axios"
  npm="https://www.npmjs.com/package/axios"
  tags={['promise', 'XMLHttpRequests']}
  links={[
    { label: 'Getting Started', link: 'https://axios-http.com/docs/intro' },
    {
      label: 'Axios default maxBodyLength = 10MB, no way to override',
      link: 'https://github.com/yakovkhalinsky/backblaze-b2/issues/45',
    },
  ]}
/>

<!-- -->

我们将实现以下特性：

**取消重复请求** 核心思想利用`set`数据结构，维护一个 pending set，里面存放 key(由 `method` + `path` + `query` + `body` 组成)和 value(取消改请求的 cacel 方法)。注意，`cancel` 是浏览器的行为，服务器仍会收到相关请求，只是浏览器不会继续对 canceled 的请求进行处理。

**取消 body size 限制** 用来解决请求包体过大，导致发出请求失败的问题

```js
import Axios from 'axios'
import type { AxiosRequestConfig } from 'axios'

const pending = new Map()
const service = Axios.create({
  baseURL: '/api',
  timeout: 1000 * 60 * 2,
  headers: { 'X-Requested-With': 'XMLHttpRequest' },
})

const addPending = (config: AxiosRequestConfig) => {
  const url = [
    config.method,
    config.url,
    JSON.stringify(config.params),
    JSON.stringify(config.data),
  ].join('&')
  const crt = config
  crt.cancelToken =
    config.cancelToken ||
    new Axios.CancelToken((cancel) => {
      if (!pending.has(url)) {
        pending.set(url, cancel)
      }
    })
}

const removePending = (config: AxiosRequestConfig) => {
  const url = [
    config.method,
    config.url,
    JSON.stringify(config.params),
    JSON.stringify(config.data),
  ].join('&')
  if (pending.has(url)) {
    // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除
    const cancel = pending.get(url)
    cancel(url)
    pending.delete(url)
  }
}

// 清除所有的请求
export const clearPending = () => {
  pending.forEach(([url, cancel]) => {
    cancel(url)
  })
  pending.clear()
}

// 设置请求拦截器
service.interceptors.request.use(
  (config) => {
    const crt = config as any
    removePending(config) // 在请求开始前，对之前的请求做检查取消操作
    addPending(config) // 将当前请求添加到 pending 中
    return crt
  },
  (error) => {
    return Promise.reject(error)
  },
)

// 设置响应拦截器，这里拦截网络请求本身的错误
service.interceptors.response.use(
  (response) => {
    removePending(response.config)
    if (response && response.data) {
      const { code, message } = response.data
    }
    return response
  },
  (error) => {
    // 如果是 cancel 引起的错误，则再次进行尝试
    if (Axios.isCancel(error)) {
      // 再次尝试 cancel
      console.error(error.message)
    }
    return Promise.reject(error)
  },
)

export const get = async (
  url: string,
  params: any,
  config: AxiosRequestConfig = {},
): Promise<any> => {
  const res = await service.get(url, {
    params,
    ...config,
  })
  return res.data || {}
}

export const post = async (
  url: string,
  body: any,
  config: AxiosRequestConfig = {},
): Promise<any> => {
  const res = await service.post(url, body, config)
  return res.data || {}
}

export const del = async (
  url: string,
  params: any,
  config: AxiosRequestConfig = {},
): Promise<any> => {
  const res = await service.delete(url, {
    params,
    ...config,
  })
  return res.data || {}
}

export const patch = async (
  url: string,
  body: any,
  config: AxiosRequestConfig = {},
): Promise<any> => {
  const res = await service.patch(url, body, config)
  return res.data || {}
}

export const put = async (
  url: string,
  body: any,
  config: AxiosRequestConfig = {},
): Promise<any> => {
  const res = await service.put(url, body, config)
  return res.data || {}
}
```
